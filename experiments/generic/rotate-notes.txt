The rotate.ced file gives a simple example of type-generic programming
using a universe.  Here, we seek to represent enum types.  Some basic
operations can then be defined, like rotating the constructors of an
enum type.  In the case of enum2 (which is isomorphic to the
booleans), rotate is just negation.

The universe of enum types is not defined explicitly as a type.
Rather, the rotate function (and others we might write) take in
the data needed to represent an enum type.  There are two pieces
of such data.  The first is a list (simple homogeneous list) of
constructors of type E, for some given type E.  The second is an
induction principle for these constructors.

It turned out to be easier (for me) to define a simply typed recursor
from the induction principle.  This is because we want to compute the
body of the rotate function by recursion on the rotated list of
constructors, but then the induction principle will not match up with
this, since it lists the cases that one must prove (when doing the
induction) in the original order (unrotated).  This simply typed
recursor is called enum-rec in the code.  It takes in the number of
constructors, rather than the list of constructors.

A theorem list-rotate-length is used to show that the recursor for the
unrotated list of constructors has the same type as the recursor for
the rotated list.  This is because the length of the original list and
the length of the rotated list are the same.

A very basic warmup would be to change this code so it can rotate
either right or left.  Don't add a separate rotate-left function.
Rather, modify rotate so that one can specify, with a boolean argument
say, whether to rotate left or right.
