import or.
import true.
import bool.


conat ◂ ★ = ∀ X : ★ . (∀ Y : ★ . (Y ➔ Or · True · Y) ➔ Y ➔ X) ➔ X .

% exchange the coalgebra (embed the new X in the conat)
unfold ◂ ∀ X : ★ . (X ➔ Or · True · X) ➔ X ➔ conat = Λ X . λ k . λ x . Λ X' . λ c . c · X k x .

fmap ◂  ∀ X : ★ . ∀ Y : ★ . (X ➔ Y) ➔ Or · True · X ➔ Or · True · Y = Λ X . Λ Y . λ f . λ o .
   o · (Or · True · Y)
       (λ _ . Ori1 · True · Y triv)
       (λ x . Ori2 · True · Y (f x)) .

out ◂ conat ➔ Or · True · conat  = λ t . t · (Or · True · conat) (Λ Y . λ k . λ c . fmap · Y · conat (unfold · Y k) (k c)).

in ◂ Or · True · conat ➔ conat = λ o . unfold · (Or · True · conat) (fmap · conat · (Or · True · conat)  out) o.

zero ◂ conat = in (Ori1 · True · conat triv).
suc ◂ conat ➔ conat  = λ n . in (Ori2 · True · conat n).
pred ◂ conat ➔ conat = λ n . out n · conat (λ _ . zero) (λ m . m) .
  
% main trick is in using the existential quantifier over the set: you can freely choose the set
out' ◂ conat ➔ Or · True · conat =   λ n . n · (Or · True · conat)
     (Λ Y . λ o . λ s . o s · (Or · True · conat)
     (λ _ . Ori1 · True · conat triv)
     (λ s' . Ori2 · True · conat (Λ X . λ c . c · Y o s') ) ).
     
suc' ◂ conat ➔conat = λ n . Λ X . λ c. c · (Or · True · conat) (λ s . fmap · conat · (Or · True · conat) out s) (Ori2 · True · conat n) .
zero' ◂ conat =  Λ X . λ c. c · (Or · True · conat) (λ s . fmap · conat · (Or · True · conat) out s) (Ori1 · True · conat triv) .
pred' ◂ conat ➔ conat =
  λ n . n · conat  (Λ Y . λ o . λ s . o s · conat (λ _ . zero) (λ s' . Λ X . λ c . c · Y o s') ).

% naive (think how "pred' one-naive" reduces)
one-naive ◂ conat = Λ X . λ c. c · conat (λ s . Ori2 · True · conat zero) zero .
one-naive-prop ◂ one-naive ≃ pred one-naive = β .

zero-naive ◂ conat = Λ X . λ c. c · True (λ s . Ori1 · True · True triv) triv .

% correct
one ◂ conat = Λ X . λ c. c · (Or · True · conat) (λ s . fmap · conat · (Or · True · conat) out s) (Ori2 · True · conat zero') .
one-prop ◂ zero' ≃ (pred' one) = β .
one-prop' ◂ suc zero' ≃ one = β .

