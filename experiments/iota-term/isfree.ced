module isfree.

import trmD.
import nat.
import valuation.
import bool.
import list.
import true.
import sigma.
import natExtras.
import posvector.
import wSigma2.

nat-eq◂Π n:Nat .Π m:Nat .Bool=●.

{- isFree function

   Note: this is a case in which the valuation of free variables differs from the valuation of bound ones in the abstraction case recursion. 
         Because of this difference, the abstraction case is simpler from its classic definition, that is,
	 it do not require to compare the variable with the binder.
-}

-- isFree◂Π n:Nat .Π m:Nat .
--        Lt m n ➔
--        Trm n ➔
--        Bool =
--   λ n .λ m .λ l .λ t .(TrmRec n t·(λ n:Nat .Π m:Nat .Lt m n➔Bool)·(λ n:Nat .λ _:(Π m:Nat .Lt m (S n)➔Bool) .True)
--     (valuationFromFun n·Trm -var·(λ n:Nat .λ _:Trm n .Π m:Nat .Lt m n➔Bool)·(λ n:Nat .λ _:(Π m:Nat .Lt m (S n)➔Bool) .True)
--       (λ n .Λ l .mkWSigma2·(Π m:Nat .Lt m (S n)➔Bool)·(λ _:(Π m:Nat .Lt m (S n)➔Bool) .True) (λ m' .λ _ .nat-eq m' m)  -triv))
--     [
--       β{λ n' . λ eval1 . λ eval2 . λ d . λ m' . λ l' . d (λ a . a (λ a1 . λ a2 . or (eval1 a1 m' l') (eval1 a2 m' l'))) (λ a . eval2 (λ _ . λ _ . ff) a m' (LtS2 m' n' l'))},
--       λ n .Λ _ .Λ _ .Λ _ .Λ _ .Λ _ .
--         λ eval1 .λ eval2 .λ d . λ m' .λ l.
--         d.1·Bool
--           (λ a .a.1·Bool
--             (λ a1 .λ a2 .or (eval1.1 a1 m' l) (eval1.1 a2 m' l)))
--           (λ a .eval2.1 (λ _ .λ _.ff) -triv a m' (LtS2 m' n l))
--     ]) m l.

isFree◂Π n:Nat .Π m:Nat .
       Trm n ➔
       Bool =
  λ n .λ m . λ t .(TrmRec n t·(λ n:Nat .Π m:Nat .Bool)·(λ n:Nat .λ _:(Π m:Nat .Bool) .True)
   (valuationFromFun n·Trm -var·(λ n:Nat .λ _:Trm n .Π m:Nat .Bool)·(λ n:Nat .λ _:(Π m:Nat .Bool) .True)
     (λ n .Λ l .mkWSigma2·(Π m:Nat .Bool)·(λ _:(Π m:Nat .Bool) .True) (λ _ .nat-eq n m)  -triv))
   [β{λ n' . λ eval1 . λ eval2 . λ d . λ m' .
     d  (λ a . a (λ a1 . λ a2 . or (eval1 a1 m') (eval1 a2 m')))
        (λ a . eval2 (λ _ . ff) a m')},
   λ n .Λ _ .Λ _ .Λ _ .Λ _ .Λ _ .λ eval1 .λ eval2 .λ d . λ m' .
     d.1·Bool
        (λ a .a.1·Bool
        (λ a1 .λ a2 .or (eval1.1 a1 m') (eval1.1 a2 m')))
          (λ a .eval2.1 (λ _ .ff) -triv a m')])
  m.


{- Alternative using valuation invariant -}
-- isFreeP◂ Π n : Nat . 
--        Trm n ➔
--        Bool =
--   λ n .λ t .TrmRec n t·(λ _:Nat .Bool)·(λ m:Nat .λ b:Bool .{b≃tt}➔{n≃m})
--    (posPV·(wSigma2·Bool·(λ b:Bool .{b≃tt}➔{n≃m}))
--       (λ m .mkWSigma2·Bool·(λ _:Bool .True) (nat-eq n m) -●)
--       n)
--    [β{λ n' . λ eval1 . λ eval2 . λ d . d (λ a . a (λ a1 . λ a2 . or (eval1 a1) (eval1 a2))) (λ a . eval2 ff a)},
--      λ _ . Λ _ .Λ _ .Λ _. Λ _ . Λ _ .
--        λ eval1 . λ eval2 . λ d .
--        d.1·Bool
--          (λ a .a.1·Bool
--            (λ a1 .λ a2 .or (eval1.1 a1) (eval1.1 a2)))
--          (λ a .eval2.1 ff -triv a)
--    ].

{-
   List of free variables in a term

   Note: Again the valuation of free variables differs from the valuation of bound ones in the abstraction case recursion. 
         Because of this difference, the abstraction case is simpler from its classic definition, that is,
	 it does not require to remove the abstraction variable from the recursive call.
-}

singleton-list◂Nat➔List·Nat=λ n .Cons·Nat n (Nil·Nat).

freeVars ◂ Π n : Nat . 
       Trm n ➔
       List·Nat =
  λ n .λ t .TrmRec n t·(λ _:Nat .List·Nat)·(λ _:Nat .λ _:List·Nat .True)
    (posPV·(λ _:Nat. wSigma2·(List·Nat)·(λ _:List·Nat .True))
      (λ n .mkWSigma2·(List·Nat)·(λ _:List·Nat .True) (singleton-list n) -triv)
      n)
    [β{λ n' . λ eval1 . λ eval2 . λ d . d (λ a . a (λ a1 . λ a2 . append (eval1 a1) (eval1 a2))) (λ a . eval2 Nil a)},
     λ n . Λ _ .Λ _ .Λ _ .Λ _ . Λ _ .
       λ eval1 . λ eval2 . λ d .
       d.1·(List·Nat)
         (λ a .a.1·(List·Nat)
           (λ a1 .λ a2 .append·Nat (eval1.1 a1) (eval1.1 a2)))
         (λ a .eval2.1 (Nil·Nat) -triv a)
     ].

{- tests -}


{- Predicate -}

-- isFreeP◂ Π n : Nat . 
--        Trm n ➔
--        ★ =
--   λ n:Nat .λ t:Trm n .TrmInd n t·(λ n:Nat .λ t:Trm n . ★)
--     ·(λ n:Nat .λ p:★ .True)
--    ●
--    [●,
--      λ _ . Λ _ .Λ _ .Λ _. Λ _ . Λ _ .
--        λ eval1 . λ eval2 . λ d .
--        d.1·★
--          (λ a .a.1·★
--            (λ a1 .λ a2 .h))
--          (λ a .●)
--    ].
