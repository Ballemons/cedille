module equality.

import trmC.
import trmD.
import nat.
import valuation.
import bool.
import list.
import true.
import sigma.
import natExtras.
import posvector.
import wSigma2.
import sum.
import product.

nat-eq◂Π n:Nat .Π m:Nat .Bool=●.

-- check if a term is an n variable
eqVar◂Π n:Nat .Trm (S n)➔Bool=
  λ n. λ t .ind-Sum·(out-t1 (S n))·(out-t2 (S n)) (out (S n) t)
    ·(λ _:Sum·(out-t1 (S n))·(out-t2 (S n)) .Bool)
    (λ t .●) 
    (λ a .ff).
    
eqTrm◂Π n:Nat .Trm n➔Trm n➔Bool=
 λ n .λ t1 .TrmRec n t1·(λ n:Nat .Trm n➔Bool)·(λ n:Nat .λ _:Trm (S n)➔Bool .True)
   (posPV·(λ m:Nat .wSigma2·(Trm (S m)➔Bool)·(λ _:(Trm (S m)➔Bool) .True))
      (λ m .mkWSigma2·(Trm (S m)➔Bool)·(λ _:(Trm (S m)➔Bool) .True) (eqVar m) -triv)
      n)
   [β{λ n' . λ eval1 . λ eval2 . λ d . d (λ a . a (λ a1 . λ a2 . λ t2 . ind-Sum (out n' t2) (λ _ . ff) (λ a . ind-Sum a (λ a . ind-Product a (λ a1' . λ a2' . and (eval1 a1 a1') (eval1 a2 a2'))) (λ a . ff)))) (λ a . λ t2 . ind-Sum (out n' t2) (λ _ . ff) (λ b . ind-Sum b (λ a . ff) (λ b . eval2 (eqVar n') a b)))},
     λ n . Λ _ .Λ _ .Λ _. Λ _ . Λ _ .
       λ eval1 . λ eval2 . λ d .
       d.1·(Trm n➔Bool)
         (λ a .a.1·(Trm n➔Bool)
           (λ a1 .λ a2 .λ t2 .ind-Sum·(out-t1 n)·(out-t2 n) (out n t2)
	      ·(λ _:Sum·(out-t1 n)·(out-t2 n) .Bool)
	      (λ _.ff) --variable case?
	      (λ a .ind-Sum·(TrmAppF·(Trm n))·(Trm (S n)) a
	      	 ·(λ _:Sum·(TrmAppF·(Trm n))·(Trm (S n)) .Bool)
	         (λ a .ind-Product·(Trm n)·(Trm n) a
		    ·(λ _:Product·(Trm n)·(Trm n) .Bool)
		    (λ a1' .λ a2' . and (eval1.1 a1 a1') (eval1.1 a2 a2'))) --application
		 (λ a .ff)))) -- abstaraction
         (λ a . λ t2 .ind-Sum·(out-t1 n)·(out-t2 n) (out n t2)
	      ·(λ _:Sum·(out-t1 n)·(out-t2 n) .Bool)
	      (λ _.ff) --variable case
	      (λ b .ind-Sum·(TrmAppF·(Trm n))·(Trm (S n)) b
	      	 ·(λ _:Sum·(TrmAppF·(Trm n))·(Trm (S n)) .Bool)
	         (λ a .ff) --application case
		 (λ b .eval2.1 (eqVar n) -triv a b))) --abstraction
   ].

-- 
