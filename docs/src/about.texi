@node about,Index,credits,Top

@chapter Cedille's Type Theory

Cedille's type theory is called the Calculus of Dependent Lambda
Eliminations (CDLE).  It is somewhat rare in being a Curry-style type
theory.  Coq and Agda are based on Church-style theories.  The
difference is that in a Curry-style (aka extrinsic) type theory, type
annotations are merely hints to the type checker, and the ``real''
terms (the subjects of metatheoretic analysis, for example) are
completely unannotated.  Thus, such annotations can be erased during
compilation and during formal reasoning (in particular during
conversion checking, where the type checker tests whether two terms
are definitionally equal).  In contrast, with Church-style (aka
intrinsic) type theory, the annotations are ``really there'', and must
be preserved during compilation and conversion.

@section Example

For an example, consider the term Œõ X : ‚òÖ . Œª x : X . x.  In Church-style
type theory, the annotations giving the classifiers for X and x are truly
part of the term, and the theory itself does not allow for them to be erased.
In contrast, in a Curry-style type theory like CDLE, those annotations are
just hints to help the type checker see how to assign the type ‚àÄ X : ‚òÖ . X ‚ûî X
to Œª x . x.  The type theory has a notion of erasure, and conversion 
compares the erasures of terms rather than the annotated terms.  

@section Cedille extends the Calculus of Constructions

The starting point for Cedille is a Curry-style version of the
Calculus of Constructions (CC).  Coq is based on several extensions of
CC, notably with a predicative universe hierarchy (Luo's Extended
Calculus of Constructions), and with a primitive system of inductive
datatypes (the Calculus of Inductive Constructions of Paulin-Mohring
and Werner).  Cedille has neither the universe hierarchy nor the
inductive types.  The universe hierarchy is omitted to avoid
additional metatheoretic and implementation complexity, which has not
been justified to my (Aaron's) satisfaction by examples.  So it is
omitted not for any really fundamental reason (that we know of).
Omitting the system of primitive inductive types, however, is one of
the chief goals of Cedille, and will be discussed more below.


@section The type constructs of Cedille

From CC, Cedille inherits the following type constructs:

@itemize
@item ‚àÄ X : ùíå . T -- this is impredicative quantification over types X of kind ùíå.
@item Œ† x : T . T' -- this is dependent function space, where the return type T' may mention the input argument x.
@item Œª X : ùíå . T -- this is a type-level function over types X of kind ùíå.
@item Œª x : T . T' -- this is a type-level function over terms x of type T.
@item T t -- this is applying a type-level function T to a term t.
@item T T' -- this is applying a type-level function T to a type T'.
@item X -- type variables are types, of course.
@end itemize

See @ref{unicode shortcuts} for how to type these symbols in Cedille mode.

To the above constructs, Cedille adds:


@section More reading 

The syntax and semantics of Cedille are described in this document
@uref{https://arxiv.org/abs/1806.04709, on arXiv}.

The paper first showing how to derive induction for an inductive type
in Cedille is @uref{https://doi.org/10.1016/j.apal.2018.03.002, here}.

