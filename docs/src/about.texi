@node about,Index,credits,Top

@chapter Cedille's Type Theory

Cedille's type theory is called the Calculus of Dependent Lambda
Eliminations (CDLE).  It is somewhat rare in being a Curry-style type
theory.  Coq and Agda are based on Church-style theories.  The
difference is that in a Curry-style (aka extrinsic) type theory, type
annotations are merely hints to the type checker, and the ``real''
terms (the subjects of metatheoretic analysis, for example) are
completely unannotated.  Thus, such annotations can be erased during
compilation and during formal reasoning (in particular during
conversion checking, where the type checker tests whether two terms
are definitionally equal).  In contrast, with Church-style (aka
intrinsic) type theory, the annotations are ``really there'', and must
be preserved during compilation and conversion.

@section Example

For an example, consider the term Œõ X : ‚òÖ . Œª x : X . x.  In Church-style
type theory, the annotations giving the classifiers for X and x are truly
part of the term, and the theory itself does not allow for them to be erased.
In contrast, in a Curry-style type theory like CDLE, those annotations are
just hints to help the type checker see how to assign the type ‚àÄ X : ‚òÖ . X ‚ûî X
to Œª x . x.  The type theory has a notion of erasure, and conversion 
compares the erasures of terms rather than the annotated terms.  

@section Cedille extends the Calculus of Constructions

The starting point for Cedille is a Curry-style version of the
Calculus of Constructions (CC).  Coq is based on several extensions of
CC, notably with a predicative universe hierarchy (Luo's Extended
Calculus of Constructions), and with a primitive system of inductive
datatypes (the Calculus of Inductive Constructions of Paulin-Mohring
and Werner).  Cedille has neither the universe hierarchy nor the
inductive types.  The universe hierarchy is omitted to avoid
additional metatheoretic and implementation complexity, which has not
been justified to my (Aaron's) satisfaction by examples.  So it is
omitted not for any really fundamental reason (that we know of).
Omitting the system of primitive inductive types, however, is one of
the chief goals of Cedille, and will be discussed more below.


@section The type constructs of Cedille

From CC, Cedille inherits the following type constructs:

@itemize
@item ‚àÄ X : ùíå . T -- this is impredicative quantification over types X of kind ùíå.
@item Œ† x : T . T' -- this is dependent function space, where the return type T' may mention the input argument x.
@item Œª X : ùíå . T -- this is a type-level function over types X of kind ùíå.
@item Œª x : T . T' -- this is a type-level function over terms x of type T.
@item T t -- this is applying a type-level function T to a term t.
@item T T' -- this is applying a type-level function T to a type T'.
@item X -- type variables are types, of course.
@end itemize

See @ref{unicode shortcuts} for how to type these symbols in Cedille mode.

To the above constructs, Cedille adds the following, discussed more below:

@itemize
@item Œπ x : T . T' -- dependent intersection of T and T', where T' may contain x.
@item @{ t ‚âÉ t' @} -- untyped equality between terms t and t'.
@item ‚àÄ x : T . T' -- the dependent type for functions taking in an erased argument x of type T (aka implicit product)
@end itemize

@subsection Dependent intersections

In (Curry-style) type theory, an intersection type T ‚à© T' can be
assigned to a term t iff both T and T' separately can be assigned to
t.  Dependent intersection types, introduced by Kopylov in
@uref{https://doi.org/10.1109/LICS.2003.1210048, this paper}, extend
this idea to allow the type T' to reference the term t (i.e., the
subject of typing) via a bound variable x.  Kopylov's notation for
this is x : T ‚à© T'.  Cedille uses the notation Œπ x : T . T' for the
same concept.

One very helpful way to think of these types is that they allow the
type T' of t to refer to t itself, but through a weaker view; namely,
the type T.  So if you are writing some function f, say, the type T'
you give for f can mention f itself -- which seems insane (as in
insane dependent typing) -- but sanity is preserved by the fact that
T' is only allowed to reference f through some other type T.

In Cedille, dependent intersections are used to derive inductive
datatypes, using a critical observation of Leivant's from
@uref{https://doi.org/10.1109/SFCS.1983.50, this paper}.  Suppose
one is trying to prove the natural-number induction principle for
a specific number N; that is, for any predicate P on natural
numbers, if the base and steps cases hold, then P holds for N.
What would the proof look like for this?  One would assume predicate P,
assume P 0 (base case) and ‚àÄ n : Nat . P n ‚ûî P (S n) (step case), and prove P N by apply the
step case N times to the base case.  Leivant's remarkable observation is that
this proof, seen through the lens of the Curry-Howard isomorphism, is

Œõ P . Œª z . Œª s . s (... (s z))

where s is applied N times.  This erases exactly to the Church-encoding of N.
This means that using the Church-encoding we can view a number N two ways:
as an iterator of type ‚àÄ X : ‚òÖ . X ‚ûî (X ‚ûî X) ‚ûî X -- call this type cNat -- and as a proof of its own
induction principle, which we can see as some kind of dependent enrichment
of the first type:

‚àÄ P : cNat ‚ûî ‚òÖ . P 0 ‚ûî (‚àÄ n : cNat . P n ‚ûî P (S n)) ‚ûî P N

Calling this second type, as a predicate on N, Inductive, the crucial role
of dependent intersection types is to allow us to define Nat as

Œπ N : cNat. Inductive N

This definition seems to allow one to prove universality of predicates on cNats -- not Nats!
But universality of Nat-predicates turns out to follow from this, in several different ways.  


@section More reading 

The syntax and semantics of Cedille are described in this document
@uref{https://arxiv.org/abs/1806.04709, on arXiv}.

The paper first showing how to derive induction for an inductive type
in Cedille is @uref{https://doi.org/10.1016/j.apal.2018.03.002, here}.

