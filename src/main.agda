module main where

import parse
import run
open import lib
open import cedille-types

-- for parser for Cedille source files
import cedille
module parsem = parse cedille.gratr2-nt ptr
open parsem.pnoderiv cedille.rrs cedille.cedille-rtn
module pr = run ptr
open pr.noderiv {- from run.agda -}

-- for parser for options files
import options
import options-types
module parsem2 = parse options.gratr2-nt options-types.ptr
module options-parse = parsem2.pnoderiv options.rrs options.options-rtn
module pr2 = run options-types.ptr
module options-run = pr2.noderiv

open import classify
open import ctxt
open import constants
open import conversion
open import general-util
open import process-cmd 
open import rec
open import spans
open import syntax-util
open import to-string
open import toplevel-state

opts : Set
opts = options-types.opts

dot-cedille-directory : string ‚Üí string 
dot-cedille-directory dir = combineFileNames dir ".cedille"

cede-filename : (ced-path : string) ‚Üí string
cede-filename ced-path = 
  let dir = takeDirectory ced-path in
  let unit-name = base-filename (takeFileName ced-path) in
    combineFileNames (dot-cedille-directory dir) (unit-name ^ ".cede")

-- .cede files are just a dump of the spans, prefixed by 'e' if there is an error
write-cede-file : (ced-path : string) ‚Üí (err : ùîπ) ‚Üí string ‚Üí IO ‚ä§
write-cede-file ced-path err contents = 
--  putStr ("write-cede-file " ^ ced-path ^ " : " ^ contents ^ "\n") >>
  let dir = takeDirectory ced-path in
    createDirectoryIfMissing ff (dot-cedille-directory dir) >>
    writeFile (cede-filename ced-path) ((if err then "e" else "") ^ contents) 

-- we assume the cede file is known to exist at this point
read-cede-file : (ced-path : string) ‚Üí IO (ùîπ √ó string)
read-cede-file ced-path = 
  get-file-contents (cede-filename ced-path) >>= Œª c ‚Üí finish c
  where finish : maybe string ‚Üí IO (ùîπ √ó string)
        finish nothing = return (tt , global-error-string ("Could not read the file " ^ cede-filename ced-path ^ "."))
        finish (just ss) with string-to-ùïÉchar ss
        finish (just ss)  | ('e' :: ss') = forceFileRead ss >> return (tt , ùïÉchar-to-string ss')
        finish (just ss) | _ = forceFileRead ss >> return (ff , ss)
  
add-cedille-extension : string ‚Üí string
add-cedille-extension x = x ^ "." ^ cedille-extension 

cedille-get-path : (dirs : ùïÉ string) ‚Üí (unit-name : string) ‚Üí IO string
cedille-get-path [] unit-name = return (add-cedille-extension unit-name) -- assume the current directory if the unit is not found 
cedille-get-path (dir :: dirs) unit-name =
  let e = combineFileNames dir (add-cedille-extension unit-name) in
    doesFileExist e >>= Œª b ‚Üí 
    if b then
      return e
    else
      cedille-get-path dirs unit-name

ced-file-up-to-date : (ced-path : string) ‚Üí IO ùîπ
ced-file-up-to-date ced-path =
  let e = cede-filename ced-path in
    doesFileExist e >>= Œª b ‚Üí 
    if b then
      fileIsOlder ced-path e
    else
      return ff

paths-to-ùïÉstring : options-types.paths ‚Üí ùïÉ string
paths-to-ùïÉstring options-types.PathsNil = []
paths-to-ùïÉstring (options-types.PathsCons p ps) = p :: paths-to-ùïÉstring ps

opts-get-include-path : opts ‚Üí ùïÉ string
opts-get-include-path options-types.OptsNil = []
opts-get-include-path (options-types.OptsCons (options-types.Lib ps) oo) = (paths-to-ùïÉstring ps) ++ opts-get-include-path oo
--opts-get-include-path (options-types.OptsCons _ oo) = opts-get-include-path oo


{- reparse the given file, and update its include-elt in the toplevel-state appropriately -}
reparse : toplevel-state ‚Üí (unit-name : string) ‚Üí (filename : string) ‚Üí IO toplevel-state
reparse s unit-name filename = 
--   putStr ("reparsing " ^ unit-name ^ " " ^ filename ^ "\n") >>
   doesFileExist filename >>= Œª b ‚Üí 
     (if b then
         (readFiniteFile filename >>= (Œª f ‚Üí return (processText f)))
      else return (error-include-elt ("The file " ^ filename ^ " could not be opened for reading."))) >>= Œª ie ‚Üí
        return (set-include-elt s unit-name ie)
  where processText : string ‚Üí include-elt
        processText x with string-to-ùïÉchar x
        processText x | s with runRtn s
        processText x | s | inj‚ÇÅ cs =
           error-include-elt ("Parse error in file " ^ filename ^ " at position " ^ (‚Ñï-to-string (length s ‚à∏ length cs)) ^ ".")
        processText x | s | inj‚ÇÇ r with rewriteRun r
        processText x | s | inj‚ÇÇ r | ParseTree (parsed-start t) :: [] = 
          new-include-elt filename t
        processText x | s | inj‚ÇÇ r | _ = error-include-elt ("Parse error in file " ^ filename ^ ".")

add-spans-if-up-to-date : (up-to-date : ùîπ) ‚Üí (filename : string) ‚Üí include-elt ‚Üí IO include-elt
add-spans-if-up-to-date up-to-date filename ie = 
  if up-to-date then
    (read-cede-file filename >>= finish)
  else
    return ie
  where finish : ùîπ √ó string ‚Üí IO include-elt
        finish (err , ss) = return (set-do-type-check-include-elt (set-spans-string-include-elt ie err ss) ff)

{- make sure that the current ast and dependencies are stored in the
   toplevel-state, updating the state as needed. -}
ensure-ast-deps : toplevel-state ‚Üí (unit-name : string) ‚Üí (filename : string) ‚Üí IO toplevel-state
ensure-ast-deps s unit-name filename with get-include-elt-if s unit-name
ensure-ast-deps s unit-name filename | nothing = 
  reparse s unit-name filename >>= Œª s ‚Üí 
  ced-file-up-to-date filename >>= Œª up-to-date ‚Üí 
  add-spans-if-up-to-date up-to-date filename (get-include-elt s unit-name) >>= Œª ie ‚Üí
  return (set-include-elt s unit-name ie)
ensure-ast-deps s unit-name filename | just ie =
  ced-file-up-to-date filename >>= Œª up-to-date ‚Üí 
    if up-to-date then 
      (add-spans-if-up-to-date up-to-date filename (get-include-elt s unit-name) >>= Œª ie ‚Üí
       return (set-include-elt s unit-name ie))
    else reparse s unit-name filename
     
{-# NO_TERMINATION_CHECK #-}
update-astsh : stringset {- seen already -} ‚Üí toplevel-state ‚Üí (unit-name : string) ‚Üí 
               IO (stringset {- seen already -} √ó toplevel-state)
update-astsh seen s unit-name = 
  cedille-get-path (toplevel-state.include-path s) unit-name >>= Œª input-filename ‚Üí 
--  putStr ("update-astsh [input-filename = " ^ input-filename ^ "]\n") >>
  if stringset-contains seen input-filename then return (seen , s)
  else (ensure-ast-deps s unit-name input-filename >>= cont (stringset-insert seen input-filename))
  where cont : stringset ‚Üí toplevel-state ‚Üí IO (stringset √ó toplevel-state)
        cont seen s with get-include-elt s unit-name
        cont seen s | ie with include-elt.deps ie 
        cont seen s | ie | ds = 
          proc seen s ds 
          where proc : stringset ‚Üí toplevel-state ‚Üí ùïÉ string ‚Üí IO (stringset √ó toplevel-state)
                proc seen s [] = 
                  if (list-any (get-do-type-check s) ds) 
                  then return (seen , set-include-elt s unit-name (set-do-type-check-include-elt ie tt)) 
                  else return (seen , s)
                proc seen s (d :: ds) = update-astsh seen s d >>= Œª p ‚Üí 
                                        proc (fst p) (snd p) ds

update-asts : toplevel-state ‚Üí (unit-name : string) ‚Üí IO toplevel-state
update-asts s unit-name = update-astsh empty-stringset s unit-name >>= Œª p ‚Üí 
  return (snd p)

checkFile : toplevel-state ‚Üí (unit-name : string) ‚Üí (should-print-spans : ùîπ) ‚Üí IO toplevel-state
checkFile s unit-name should-print-spans = 
--  putStr ("checkFile " ^ unit-name ^ "\n") >>
  update-asts s unit-name >>= Œª s ‚Üí 
  finish (process-unit s unit-name)
 
  where reply : toplevel-state ‚Üí IO ‚ä§
        reply s with get-include-elt-if s unit-name
        reply s | nothing = 
           putStr (global-error-string 
                     ("Internal error looking up information for unit " ^ unit-name ^ "."))
        reply s | just ie =
           if should-print-spans then putStr (include-elt.ss ie) 
           else return triv
        finish : toplevel-state ‚Üí IO toplevel-state
        finish s with s
        finish s | mk-toplevel-state ip mod is Œì = 
          writeo mod >>
          reply s >>
          return (mk-toplevel-state ip [] is Œì)
          where writeo : ùïÉ string ‚Üí IO ‚ä§
                writeo [] = return triv
                writeo (unit :: us) =
                 let ie = get-include-elt s unit in
--                   putStr ("writeo " ^ unit ^ " with path " ^ (include-elt.path ie) ^ ".\n") >>
                   write-cede-file (include-elt.path ie) (include-elt.err ie) (include-elt.ss ie) >>
                   writeo us

{-# NO_TERMINATION_CHECK #-}
readFilenamesForProcessing : toplevel-state ‚Üí IO ‚ä§
readFilenamesForProcessing s =
  getLine >>= (Œª input-filename ‚Üí 
     checkFile (set-include-path s (toplevel-state.include-path s))
       (base-filename (takeFileName input-filename)) tt {- should-print-spans -} >>= Œª s ‚Üí 
     readFilenamesForProcessing s)

processArgs : opts ‚Üí ùïÉ string ‚Üí IO ‚ä§ 
processArgs oo (input-filename :: []) with (base-filename (takeFileName input-filename)) 
processArgs oo (input-filename :: []) | unit-name = 
  checkFile (new-toplevel-state (opts-get-include-path oo)) unit-name ff {- should-print-spans -} >>= finish
  where finish : toplevel-state ‚Üí IO ‚ä§
        finish s = 
          let ie = get-include-elt s unit-name in
          if include-elt.err ie then putStr (include-elt.ss ie) else return triv
processArgs oo [] = readFilenamesForProcessing (new-toplevel-state (opts-get-include-path oo))
processArgs oo xs = putStr ("Run with the name of one file to process, or run with no command-line arguments and enter the\n"
                         ^ "names of files one at a time followed by newlines (this is for the emacs mode).\n")

processOptions : string ‚Üí string ‚Üí (string ‚äé options-types.opts)
processOptions filename s with string-to-ùïÉchar s
processOptions filename s | i with options-parse.runRtn i
processOptions filename s | i | inj‚ÇÅ cs =
  inj‚ÇÅ ("Parse error in file " ^ filename ^ " at position " ^ (‚Ñï-to-string (length i ‚à∏ length cs)) ^ ".")
processOptions filename s | i | inj‚ÇÇ r with options-parse.rewriteRun r
processOptions filename s | i | inj‚ÇÇ r | options-run.ParseTree (options-types.parsed-start (options-types.File oo)) :: [] = inj‚ÇÇ oo
processOptions filename s | i | inj‚ÇÇ r | _ =  inj‚ÇÅ ("Parse error in file " ^ filename ^ ". ")

readOptions : IO (string ‚äé options-types.opts)
readOptions =
  getHomeDirectory >>= Œª homedir ‚Üí
    let homecedir = dot-cedille-directory homedir in
    let optsfile = combineFileNames homecedir options-file-name in
      createDirectoryIfMissing ff homecedir >>
      doesFileExist optsfile >>= Œª b ‚Üí 
       if b then
         (readFiniteFile optsfile >>= Œª f ‚Üí return (processOptions optsfile f))
       else
         (return (inj‚ÇÇ options-types.OptsNil))

main : IO ‚ä§
main = readOptions >>= next
  where next : string ‚äé options-types.opts ‚Üí IO ‚ä§
        next (inj‚ÇÅ s) = putStr (global-error-string s)
        next (inj‚ÇÇ oo) = getArgs >>= processArgs oo

