
import ../../../util/RecType.

% Try to write some RecType machinery for NatParamF to enable this development
% to go through. Just an indexed functor Cast and RecType equivalent?



NatF ◂ ★ ➔ ★ = λ Nat' : ★ . ∀ X : ★ . X ➔ (Nat' ➔ X ➔ X) ➔ X .

NatFzero ◂ ∀ Nat' : ★ . NatF · Nat' =  Λ Nat' . Λ X . λ z . λ s . z .

NatFmap ◂ RecFunctor · NatF = Λ A . Λ B . λ c . [ λ x . Λ X . λ z . λ s . x · X z (λ a . s (cast · A · B -c a) )  ,
                                λ a . β{a} ].

Nat' ◂ ★ = Rec · NatF .

Nat'Out ◂ Nat' ➔ (NatF · Nat') = cast · Nat' · (NatF · Nat') -(recOut · NatF -NatFmap) .

NatParamF ◂ (Nat' ➔ ★) ➔ (Nat' ➔ ★) = λ R' : Nat' ➔ ★ . λ x : Nat' . ∀ A : ★ . ∀ R : A ➔ ★ . ∀ a : A .
  R a ➔ ∀ f : Nat' ➔ A ➔ A . (∀ n : Nat' . ∀ a : A . (R' n) ➔ (R a) ➔ R (f n a)) ➔ R (Nat'Out x · A a f) .

𝒌 = Nat' ➔ ★ .
NatCast ◂ 𝒌 ➔ 𝒌 ➔ ★ = λ A : 𝒌 . λ B : 𝒌 .
       ι cast : ∀ n : Nat' . A n ➔ B n . cast ≃ λ x . x.

natcast ◂ ∀ A : 𝒌 . ∀ B : 𝒌 . NatCast · A · B ➾ ∀ n : Nat' . A n ➔ B n =
  Λ A . Λ B . Λ c . Λ n . λ a . (χ (ι _ : A n . B n) - [ a , c.1 -n a { ρ c.2 - β } ]).2 .

NatRecFunctor ◂ (𝒌 ➔ 𝒌) ➔ ★ =
  λ F : 𝒌 ➔ 𝒌 . ∀ X : 𝒌 . ∀ Y : 𝒌 . NatCast · X · Y ➔ NatCast · (F · X) · (F · Y) .

NatRec ◂ (𝒌 ➔ 𝒌) ➔ 𝒌 = λ F : 𝒌 ➔ 𝒌 . λ n : Nat' . ∀ X : 𝒌 . NatCast · (F · X) · X ➾ X n. 

NatrecCast ◂ ∀ F : 𝒌 ➔ 𝒌 . ∀ X : 𝒌 . NatCast · (F · X) · X ➾ NatCast · (NatRec · F) · X =
  Λ F . Λ X . Λ c . [ Λ A . λ d . d · X -c , β{λ a . a} ].

NatrecIn ◂ ∀ F : 𝒌 ➔ 𝒌 . NatRecFunctor · F ➾ NatCast · (F · (NatRec · F)) · (NatRec · F) =
  Λ F . Λ fmap . 
    [ Λ n . λ x . Λ X . Λ c .
      natcast · (F · X) · X -c -n
        (natcast · (F · (NatRec · F)) · (F · X)
          -(fmap · (NatRec · F) · X (NatrecCast · F · X -c)) -n x),
      β{λ a . a} ].

NatrecOut ◂ ∀ F : 𝒌 ➔ 𝒌 . NatRecFunctor · F ➾ NatCast · (NatRec · F) · (F · (NatRec · F)) =
  Λ F . Λ fmap . [Λ n . λ x . x · (F · (NatRec · F)) -(fmap · (F · (NatRec · F)) · (NatRec · F) (NatrecIn · F -fmap)) , β{λ x . x} ].

NatrecFold ◂ ∀ F : 𝒌 ➔ 𝒌 . NatRecFunctor · F ➾ NatCast · (F · (NatRec · F)) · (NatRec · F) = NatrecIn .
NatrecUnfold ◂ ∀ F : 𝒌 ➔ 𝒌 . NatRecFunctor · F ➾ NatCast · (NatRec · F) · (F · (NatRec · F)) = NatrecOut .

NatrecIso1 ◂ ∀ a : Top . NatrecFold (NatrecUnfold a) ≃ a = Λ a . β.
NatrecIso2 ◂ ∀ a : Top . NatrecUnfold (NatrecFold a) ≃ a = Λ a . β.

NatParam ◂ Nat' ➔ ★ = NatRec · NatParamF.

NatPreSuc ◂ Nat' ➔ NatF · Nat' =
  λ p . Λ X . λ z . λ s . s p ( (cast · Nat' · (NatF · Nat') -(recOut · NatF -NatFmap) p) · X z s) .

Z' ◂ Nat' =  cast · (NatF · Nat') · Nat' -(recFold · NatF -NatFmap) (NatFzero · (Rec · NatF)).
S' ◂ Nat' ➔ Nat' = λ p . cast · (NatF · Nat') · Nat' -(recFold · NatF -NatFmap) (NatPreSuc p) .

Nat ◂ ★ = ι x : Nat' . ι u : (x Z' (λ p . λ r . S' p)) ≃ x . NatParam x .

% what is the "rebuilding equation" for Parigot nats?
% presumably it looks like (n (λ p . λ r . p) Z' = n)

Z ◂ Nat = [ Z' , [β{Z'} , ● ]]  .
S ◂ Nat ➔ Nat = 
  λ n : Nat . [ S' n.1 , [εl (εr β{S' n.1}), Λ A . Λ R . Λ f . λ s . Λ a . λ z . s -(Nat'Out n.1 · A f a) n.1 (n.2.2 · A · R -f s -a z) ]] .

Ind ◂ Π x : Nat . ∀ Q : Nat ➔ ★ . (Π x : Nat . Q x ➔ Q (S x)) ➔ Q Z ➔ Q x =
  λ x . Λ Q . λ s . λ z . 
    ρ ς x.2.1 - (x.2.2 · Nat · Q -(λ p : Nat' . λ r . S r) (λ a . λ n . λ qa . s a qa) -Z z) .
