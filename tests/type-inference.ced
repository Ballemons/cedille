module type-inference  .

import true .
import cnat .
import nat .
import cast .
import depcast .
import list .
import clist .
import product .
import sigma .

-- (Y) for definitions expected to type check with no errors,
-- (N) for definitions expected to fail to synthesize all type args
-- (B) for a bug

-- (Y) infer A : ★
test1 ◂ ∀ A : ★ . A ➔ A
      = Λ A . λ a . triv {- · A -} a .

-- (Y) infer cNat : ★
test2 ◂ cNat
      = triv {- · cNat -} cZ .

-- (Y) infer A B : ★
test-cast ◂ ∀ A : ★ . ∀ B : ★ . Cast · A · B ➾ A ➔ B
     	  = Λ A . Λ B . Λ c . λ a .
	    changeType {- · A · B -} a -(c.1 a) -(ρ c.2 - β).
--          ^------------------------^
-- select the above span to see how unsolved type param B
-- is displayed

-- (Y) infer A : ★ and B : A ➔ ★
-- don't get your hopes up, HO type arguments will only be inferred
-- when they appear directly in the type of a synthesized term, such as
-- `c' below
test-e2i ◂ ∀ A : ★ . ∀ B : A ➔ ★ . CastE · A · B ➾ CastI · A · B
	 = Λ A . Λ B . Λ c .
	     [ (λ a . castE {- · A · B -} -c a)
	     , β{λ x . x} ] .

-- (Y) infer X : ★, Q : X ➔ ★
Cons' ◂ ∀ A : ★ . A ➔ List · A ➔ List · A
      = Λ A . λ h . λ t .
      	  [ cCons · A h t.1 ,
	    [ ε ρ t.2.1 - β{cCons h t} ,
	      Λ X . Λ Q . Λ cons . Λ nil . λ c . λ n .
	      	c h -(t.1 cons nil)
		  (t.2.2 {- X · Q -} -cons -nil c  n)]].
--                 ^--------------------------^ ^^
-- Compare the two spans above to see why we can infer Q from c

-- (N) X : ★
-- We are currently not using the expected result type, Nat,
-- eagerly. If we did, we could check argument (λ _ . S) below
test-length
 ◂ ∀ A : ★ . List · A ➔ Nat
 = Λ A . λ l . ListRec {- · A -} l {- · Nat-} (λ _ . S) Z .
--             ^-----------------^
-- Select the span above to see that the expected argument type
-- isn't complete - we try to synthesize the type of (λ _ . S)
-- and fail

-- vv just a re-arrangement of cList sig vv
cFoldr ◂ ∀ A : ★ . ∀ X : ★ . cList · A ➔ X ➔ (A ➔ X ➔ X) ➔ X
       = Λ A . Λ X . λ l . λ n . λ c . l c n .

-- (Y) X : ★
-- In this case you can "cheat" by re-arranging the order of the arguments
test-length-2
 ◂ ∀ A : ★ . cList · A ➔ cNat
 = Λ A . λ l . cFoldr l cZ (λ _ . cS) .
--             ^------^ ^^
-- cZ is provided first, so we find a solution for X

-- (N) X : ★
-- More of the same, we need to use the expected type A
test-pproj1 ◂ ∀ A : ★. ∀ B : ★. Product · A · B ➔ A 
 = Λ A. Λ B. λ s. s.1 {- · A -} (λ a. λ _. a).

-- (N) X : ★
-- More of the same, we need to use the expected type B
test-pproj2 ◂ ∀ A : ★. ∀ B : ★. Product · A · B  ➔ B 
 = Λ A. Λ B. λ s. s.1 {- · B -} (λ _. λ b. b).


-- (N) (∀ A : ★. List · A) <: List · B
-- No polymorphic constants either (Nil).

-- side note: another example where the inherrited type could help
-- complete the information needed for the functional argument - we
-- could elide List · B if we did so
test-map
 ◂ ∀ A : ★ . ∀ B : ★ . (A ➔ B) ➔ List · A ➔ List · B
 = Λ A . Λ B . λ f . λ l .
     ListRec l · (List · B) (λ a . λ bl . Cons (f a) bl) (Nil {-· B-}).

-- (N) X : ★
-- We will not try to do inference when the type of the application head
-- doesn't even reveal an arrow, even when it is a meta-var
test-bot1 ◂ (∀ A : ★ . A) ➔ cNat
	 =   λ b . b cZ .

-- (Y) X : ★
-- In that case you do have to instantiate explicitly.
-- Note that if you instantiate with a poly-type, new type variables
-- will also be solved by type inference
test-bot2 ◂ (∀ A : ★ . A) ➔ cNat
	  = λ b . b · (∀ A : ★ . A ➔ A) cZ .


-- Bugs
----------------------------------------------------------------------

-- (B) This should be a type error, a "escapes" its scope
proj2' = Λ A : ★. Λ B : A ➔ ★. λ s : Sigma · A · B.
       	 s.1 (λ a : A. λ b : B a. b).
--           ^---------------------^
--           Synthesized type for this is wrong
--           The ∀ version had the right behavior though

-- (B) [FIXED]
-- The original version of the error
Stigma' ◂ Π A : ★. (A ➔ ★) ➔ ★ = λ A : ★. λ B : A ➔ ★. ∀ X : ★. (∀ a : A. B a ➔ X) ➔ X.
{- a escaping its scope -}
proj2'' = Λ A : ★. Λ B : A ➔ ★. λ s : Stigma' · A · B. s (Λ a : A. λ b : B a. b).


-- (B) [FIXED]
-- Strange shadowing bug
test-hnf-bug ◂ Nat
	     = cFoldr (Λ X : ★ . λ f : (Nat ➔ X ➔ X) . λ n : X . n) Z add .

-- (B) [FIXED] Not unfolding definitions
-- This also occurs when I try to omit explicit type
-- arguments to appendV2appendL in examples/reuse/combs/Examples.ced
-- (in the outermost copyType)
test-unfold-rhs
  ◂ ∀ A : ★ . A ➔ A
  = Λ A . cast -(χ (Cast · A · A) - (castId · A)) .

-- (B) [FIXED] Meta-variable solutions aren't kind-checked, leading to bogus inferences
test-mv-check ◂ ∀ A1 : ★ . ∀ A2 : ★ . ∀ B1 : A1 ➔ ★ . ∀ B2 : A2 ➔ ★ .
	        ∀ C1 : (A1 ➔ ★) ➔ ★ . C1 · B1
		➔ (∀ B2 : A2 ➔ ★ . ∀ C2 : (A2 ➔ ★) ➔ ★ . C2 · B2 ➔ C2 · B2)
		➔ C1 · B1
	      = Λ A1 . Λ A2 . Λ B1 . Λ B2 . Λ C1 . λ c1 . λ fc2 .
	      	  fc2 {- · B2 -} c1 .
--                ^---------------^
-- Uncomment explicit type to see issue.
-- B2 is being infered as a solution, even though it is type-
-- incorrect to provide explicitly

-- (B) (Expected: ???)
--
-- The type synthesized for pb changes from P (cast -c a) to just P
-- (cast a), meaning when we go to check that our solution P (cast a)
-- for meta-var ?A' has type ★, we fail because we cannot check cast a
-- : B since cast requires an erased argument -c firstx
test-erased-terms
  ◂ ∀ A : ★ . ∀ B : ★ . ∀ P : B ➔ ★ .
    Π c : Cast · A · B . Π f : (∀ A : ★ . A ➔ Nat) . Π a : A . P (cast -c a) ➔ Nat
  = Λ A . Λ B . Λ P . λ c . λ f . λ a . λ pb .
      f {- · (P (cast -c a)) -} pb .
--    ^--------------------------^

-- Future Considerations
----------------------------------------------------------------------

-- A fundamental issue with greedy and subsumptive inference
test-greedy
  ◂ (∀ A : ★ . A ➔ A ➔ Nat) ➔ ((Nat ➔ Nat) ➔ Nat) ➔ ((∀ B : ★ . B ➔ B) ➔ Nat) ➔ Nat
  = λ f . λ x . λ y . f x y .

-- Not only does the most general type (∀ A : ★ . A ➔ A) ➔ Nat have to be infered,
-- but a coercion has to be findable for x to give it that type
test-greedy-ok
  ◂ (∀ A : ★ . A ➔ A ➔ Nat) ➔ ((Nat ➔ Nat) ➔ Nat) ➔ ((∀ B : ★ . B ➔ B) ➔ Nat) ➔ Nat
  = λ f . λ x . λ y . f · ((∀ A : ★ . A ➔ A) ➔ Nat) (λ f . x (f · Nat)) y .
