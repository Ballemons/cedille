module tpinf .

import nat .
import bool .
import sigma .
import list .
import true .
import cast .

-- Meta-var localities
-- ==================================================

test-new-mvar
◂ ∀ A : ★ . A ➔ A
= Λ A . λ a . triv a .

test-cast
◂ ∀ A : ★ . ∀ B : ★ . Cast · A · B ➾ A ➔ B
= Λ A . Λ B . Λ c . λ a .
    changeType {- · A · B -} a -(c.1 a) -(ρ c.2 - β).
--  ^----------------------------------------------^
--  ^------------------------^

-- Every maximal application and locality that is *not* an error now has a
-- tagged-val in its span that shows you all meta-variables and solutions. From
-- here you can jump to their introduction sites

test-locale
◂ Π const : ∀ X : ★ . ∀ Y : ★ . X ➔ Y ➔ X .
  ∀ A : ★ . A ➔ A
= λ const . Λ A . λ a . const const a a a .

-- Inapplicability errors
-- ==================================================

error-inapplicable
◂ (∀ X : ★ . X) ➔ Nat ➔ Nat
= λ bot . λ n . bot n .

-- Unmatchable errors
-- ==================================================

-- Solutions contain local variables
-- --------------------------------------------------

error-local-var
  = Λ A : ★. Λ B : A ➔ ★. λ s : Sigma · A · B.
      s.1 (λ a : A. λ b : B a. b).

-- Incompatible solutions
-- --------------------------------------------------

error-ineq-sols
  ◂ (∀ A : ★ . (A ➔ A) ➔ A) ➔ Nat
  = λ fix . fix (λ x : Bool . Z) .

-- The meta-variable and its two solutions are shown. There's an additional,
-- seemingly redundant field for all meta-variables present in the type, which
-- in this example is only ?A

-- Unmatchable arrows / abstractors
-- --------------------------------------------------

error-ineq-arrow
  ◂ (∀ A : ★ . (A ➾ A) ➔ A) ➔ Nat
  = λ res . res S  .

-- Least informative unmatchable
-- --------------------------------------------------

-- When matching, we first try to match the types as given, and if that fails
-- continuously head-normalize the types as we try to make a match again. (See issue #7).
-- Even the continuously unfolding approach may still fail, so we must choose
-- between reporting a likely inaccurate error or a more accurate, but more
-- unfolded one.

-- Since the expected / computed argument types are printed compact, I lean in
-- favor of printing the lhs / rhs erros unfolded, since in some cases this can
-- be helpful (see below).

error-type-ineq1
  ◂ ∀ A : ★ . List · A ➔ Nat
  = Λ A . λ l . ListRec {- · A -} Z {- · Nat-} (λ _ . S) Z .

error-type-ineq2
  ◂ ∀ A : ★ . List · A ➔ Nat
  = Λ A . λ l . ListRec {- · A -} Nil {- · Nat-} (λ _ . S) Z .

-- Misc
-- ==================================================

-- Ill-kinded meta-variable solutions
-- --------------------------------------------------

-- TODO Strange highlighting bug when kind-checking solutions
error-illkinded-sol
  ◂ ∀ A1 : ★ . ∀ A2 : ★ . ∀ B1 : A1 ➔ ★ . ∀ B2 : A2 ➔ ★ .
    ∀ C1 : (A1 ➔ ★) ➔ ★ . C1 · B1
    ➔ (∀ B2 : A2 ➔ ★ . ∀ C2 : (A2 ➔ ★) ➔ ★ . C2 · B2 ➔ C2 · B2)
    ➔ C1 · B1
  = Λ A1 . Λ A2 . Λ B1 . Λ B2 . Λ C1 . λ c1 . λ fc2 .
      fc2 {- · B2 -} c1 .

-- Unsolved meta-variables
-- --------------------------------------------------

error-unsolved-metavars
  ◂ (∀ Y : ★ . ∀ X : ★ . X ➔ ∀ Z : ★ . X ➔ Nat) ➔ Nat ➔ Nat
  = λ f . λ x . f x x .

-- More exotic errors
-- ==================================================

-- copy-paste bug resolved
-- [[file:type-inference/tpinf-bug-copypaste.ced][file:~/vc/cedille/tests/type-inference/tpinf-bug-copypaste.ced]]

-- Motivation for more unfolded types in some errors
-- [[file:~/vc/ds18-efficient-mendler/CoV/CVFixIndM.ced::cvOutFixIndM%20%E2%97%82%20%E2%88%80%20F%20:%20%E2%98%85%20%E2%9E%94%20%E2%98%85.%20%E2%88%80%20imap%20:%20IdMapping%20%C2%B7%20F.%20CVFixIndM%20%C2%B7%20F%20imap%20%E2%9E%94%20F%20%C2%B7%20(CVFixIndM%20%C2%B7%20F%20imap)]]


