{"spans":[["Cedille source file (S-1.ced)",1,354,{}],["Term-level definition (checking)",253,350,{"summary":"0 S-ineq-bool : Π x : Nat . ((eqnat (S x) x) ≃ ff)","erasure":"1 λ x . (x (λ px . λ h . β) β)"}],["Application of a term to a term",312,348,{"language-level":"0 term","expected-type":"1 ((eqnat (S x) x) ≃ ff)","type":"2 ((eqnat (S x) x) ≃ ff)"}],["Beta axiom",347,348,{"language-level":"0 term","explanation":"1 A term constant whose type states that β-equal terms are provably equal","type":"2 ((eqnat (S Z) Z) ≃ ff)"}],["Application of a term to a term",312,342,{"language-level":"0 term","type":"1 ((λ x : Nat . ((eqnat (S x) x) ≃ ff)) Z) → ((λ x : Nat . ((eqnat (S x) x) ≃ ff)) x)"}],["Rho",333,340,{"language-level":"0 term","the equation":"1 ((eqnat (S px) px) ≃ ff)","type":"2 ((eqnat (S (S px)) (S px)) ≃ ff)","explanation":"3 Rewrite terms in the expected type, using an equation. "}],["Beta axiom",339,340,{"language-level":"0 term","explanation":"1 A term constant whose type states that β-equal terms are provably equal","type":"2 (ff ≃ ff)"}],["Term variable",335,336,{"language-level":"0 term","location":"1 S-1.ced - 329","symbol":"2 h","type":"3 (λ x : Nat . ((eqnat (S x) x) ≃ ff)) px","hnf of type":"4 ((eqnat (S px) px) ≃ ff)"}],["Term variable",329,330,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 h","type":"3 (λ x : Nat . ((eqnat (S x) x) ≃ ff)) px","hnf of type":"4 ((eqnat (S px) px) ≃ ff)"}],["Lambda abstraction (term-level)",327,340,{"language-level":"0 term","binder":"1 0","type":"2 ((λ x : Nat . ((eqnat (S x) x) ≃ ff)) px) → ((λ x : Nat . ((eqnat (S x) x) ≃ ff)) (S px))"}],["Punctuation",327,328,{"not-for-navigation":"0 true"}],["Term variable",322,324,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 px","type":"3 Nat","hnf of type":"4 Nat"}],["Lambda abstraction (term-level)",320,340,{"language-level":"0 term","binder":"1 0","type":"2 Π n : Nat . (((λ x : Nat . ((eqnat (S x) x) ≃ ff)) n) → ((λ x : Nat . ((eqnat (S x) x) ≃ ff)) (S n)))"}],["Punctuation",320,321,{"not-for-navigation":"0 true"}],["Punctuation",318,342,{"not-for-navigation":"0 true"}],["Application of a term to a type",312,313,{"language-level":"0 term","type":"1 (Π n : Nat . (((λ x : Nat . ((eqnat (S x) x) ≃ ff)) n) → ((λ x : Nat . ((eqnat (S x) x) ≃ ff)) (S n)))) → ((λ x : Nat . ((eqnat (S x) x) ≃ ff)) Z) → ((λ x : Nat . ((eqnat (S x) x) ≃ ff)) x)"}],["Term variable",312,313,{"language-level":"0 term","location":"1 S-1.ced - 306","symbol":"2 x","type":"3 Nat","hnf of type":"4 Nat"}],["Theta",310,349,{"language-level":"0 term","expected-type":"1 ((eqnat (S x) x) ≃ ff)","the motive":"2 λ x : Nat . ((eqnat (S x) x) ≃ ff)","explanation":"3 Perform an elimination with the first term, after abstracting it from the expected type."}],["Term variable",306,307,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 x","type":"3 Nat","hnf of type":"4 Nat"}],["Lambda abstraction (term-level)",304,349,{"language-level":"0 term","binder":"1 0","type":"2 Π x : Nat . ((eqnat (S x) x) ≃ ff)"}],["Punctuation",304,305,{"not-for-navigation":"0 true"}],["Equation",279,299,{"language-level":"0 type","kind":"1 ★"}],["Term variable",297,299,{"language-level":"0 term","location":"1 /space/guneratne/cedille-stuff/cedille/lib/bool.ced - 52","symbol":"2 ff"}],["Term variable",293,294,{"language-level":"0 term","location":"1 S-1.ced - 269","symbol":"2 x"}],["Term variable",289,290,{"language-level":"0 term","location":"1 S-1.ced - 269","symbol":"2 x"}],["Term variable",287,288,{"language-level":"0 term","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat.ced - 41","symbol":"2 S"}],["Term variable",279,284,{"language-level":"0 term","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat.ced - 930","symbol":"2 eqnat"}],["Term variable",269,270,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 x","type":"3 Nat","hnf of type":"4 Nat"}],["Type variable",273,276,{"language-level":"0 type","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat.ced - 35","symbol":"2 Nat","expected kind":"3 ★","kind":"4 ★"}],["Punctuation",267,268,{"not-for-navigation":"0 true"}],["Dependent function type",267,299,{"language-level":"0 type","binder":"1 0","kind":"2 ★"}],["Term-level definition (checking)",132,251,{"summary":"0 S-add-one-1 : Π n : Nat . ((add n one) ≃ (S n))","erasure":"1 λ n . (n (λ p . λ h . β) β)"}],["Application of a term to a term",186,249,{"language-level":"0 term","expected-type":"1 ((add n one) ≃ (S n))","type":"2 ((add n one) ≃ (S n))"}],["Beta axiom",248,249,{"language-level":"0 term","explanation":"1 A term constant whose type states that β-equal terms are provably equal","type":"2 ((add Z one) ≃ (S Z))"}],["Application of a term to a term",186,243,{"language-level":"0 term","type":"1 ((λ n : Nat . ((add n one) ≃ (S n))) Z) → ((λ n : Nat . ((add n one) ≃ (S n))) n)"}],["Rho",209,241,{"language-level":"0 term","the equation":"1 ((add p one) ≃ (S p))","type":"2 ((λ s . λ z' . (s (p (λ n' . S) one) (p (λ n' . S) one s z'))) ≃ (S (S p)))","explanation":"3 Rewrite terms in the expected type, using an equation. "}],["Rho",215,241,{"language-level":"0 term","the equation":"1 ((add n (S Z)) ≃ (S (add n Z)))","type":"2 ((λ s . λ z' . (s (S p) (S p s z'))) ≃ (S (S p)))","explanation":"3 Rewrite terms in the expected type, using an equation. "}],["Beta axiom",240,241,{"language-level":"0 term","explanation":"1 A term constant whose type states that β-equal terms are provably equal","type":"2 ((λ s . λ z' . (s (S p) (S p s z'))) ≃ (S (S p)))"}],["Application of a term to a term",219,235,{"language-level":"0 term","type":"1 ((add n (S Z)) ≃ (S (add n Z)))"}],["Term variable",234,235,{"language-level":"0 term","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat.ced - 57","symbol":"2 Z","expected-type":"3 Nat","type":"4 Nat"}],["Application of a term to a term",219,233,{"language-level":"0 term","type":"1 Π m : Nat . ((add n (S m)) ≃ (S (add n m)))"}],["Term variable",232,233,{"language-level":"0 term","location":"1 S-1.ced - 180","symbol":"2 n","expected-type":"3 Nat","type":"4 Nat"}],["Term variable",219,231,{"language-level":"0 term","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat-thms/add/add-0.ced - 323","symbol":"2 add-S-comm-1","type":"3 Π n : Nat . Π m : Nat . ((add n (S m)) ≃ (S (add n m)))","hnf of type":"4 Π n : Nat . Π m : Nat . ((add n (S m)) ≃ (S (add n m)))"}],["Punctuation",217,237,{"not-for-navigation":"0 true"}],["Term variable",211,212,{"language-level":"0 term","location":"1 S-1.ced - 202","symbol":"2 h","type":"3 (λ n : Nat . ((add n one) ≃ (S n))) p","hnf of type":"4 ((add p one) ≃ (S p))"}],["Epsilon",206,241,{"language-level":"0 term","type":"1 ((add (S p) one) ≃ (S (S p)))","explanation":"2 Normalize the left-hand side of the expected equation, using head reduction."}],["Term variable",202,203,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 h","type":"3 (λ n : Nat . ((add n one) ≃ (S n))) p","hnf of type":"4 ((add p one) ≃ (S p))"}],["Lambda abstraction (term-level)",200,241,{"language-level":"0 term","binder":"1 0","type":"2 ((λ n : Nat . ((add n one) ≃ (S n))) p) → ((λ n : Nat . ((add n one) ≃ (S n))) (S p))"}],["Punctuation",200,201,{"not-for-navigation":"0 true"}],["Term variable",196,197,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 p","type":"3 Nat","hnf of type":"4 Nat"}],["Lambda abstraction (term-level)",194,241,{"language-level":"0 term","binder":"1 0","type":"2 Π n' : Nat . (((λ n : Nat . ((add n one) ≃ (S n))) n') → ((λ n : Nat . ((add n one) ≃ (S n))) (S n')))"}],["Punctuation",194,195,{"not-for-navigation":"0 true"}],["Punctuation",192,243,{"not-for-navigation":"0 true"}],["Application of a term to a type",186,187,{"language-level":"0 term","type":"1 (Π n' : Nat . (((λ n : Nat . ((add n one) ≃ (S n))) n') → ((λ n : Nat . ((add n one) ≃ (S n))) (S n')))) → ((λ n : Nat . ((add n one) ≃ (S n))) Z) → ((λ n : Nat . ((add n one) ≃ (S n))) n)"}],["Term variable",186,187,{"language-level":"0 term","location":"1 S-1.ced - 180","symbol":"2 n","type":"3 Nat","hnf of type":"4 Nat"}],["Theta",184,250,{"language-level":"0 term","expected-type":"1 ((add n one) ≃ (S n))","the motive":"2 λ n : Nat . ((add n one) ≃ (S n))","explanation":"3 Perform an elimination with the first term, after abstracting it from the expected type."}],["Term variable",180,181,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 n","type":"3 Nat","hnf of type":"4 Nat"}],["Lambda abstraction (term-level)",178,250,{"language-level":"0 term","binder":"1 0","type":"2 Π n : Nat . ((add n one) ≃ (S n))"}],["Punctuation",178,179,{"not-for-navigation":"0 true"}],["Equation",158,173,{"language-level":"0 type","kind":"1 ★"}],["Term variable",172,173,{"language-level":"0 term","location":"1 S-1.ced - 148","symbol":"2 n"}],["Term variable",170,171,{"language-level":"0 term","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat.ced - 41","symbol":"2 S"}],["Term variable",164,167,{"language-level":"0 term","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat.ced - 219","symbol":"2 one"}],["Term variable",162,163,{"language-level":"0 term","location":"1 S-1.ced - 148","symbol":"2 n"}],["Term variable",158,161,{"language-level":"0 term","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat.ced - 238","symbol":"2 add"}],["Term variable",148,149,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 n","type":"3 Nat","hnf of type":"4 Nat"}],["Type variable",152,155,{"language-level":"0 type","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat.ced - 35","symbol":"2 Nat","expected kind":"3 ★","kind":"4 ★"}],["Punctuation",146,147,{"not-for-navigation":"0 true"}],["Dependent function type",146,173,{"language-level":"0 type","binder":"1 0","kind":"2 ★"}],["Term-level definition (checking)",29,130,{"summary":"0 S-refl-iter : Π x : Nat . (x ≃ (x (λ p . S) Z))","erasure":"1 λ x . β"}],["Rho",85,128,{"language-level":"0 term","the equation":"1 ((x (λ p . S) Z) ≃ (add x Z))","type":"2 (x ≃ (x (λ p . S) Z))","explanation":"3 Rewrite terms in the expected type, using an equation. "}],["Rho",109,128,{"language-level":"0 term","the equation":"1 ((add x Z) ≃ x)","type":"2 (x ≃ (add x Z))","explanation":"3 Rewrite terms in the expected type, using an equation. "}],["Beta axiom",127,128,{"language-level":"0 term","explanation":"1 A term constant whose type states that β-equal terms are provably equal","type":"2 (x ≃ x)"}],["Application of a term to a term",113,122,{"language-level":"0 term","type":"1 ((add x Z) ≃ x)"}],["Term variable",121,122,{"language-level":"0 term","location":"1 S-1.ced - 81","symbol":"2 x","expected-type":"3 Nat","type":"4 Nat"}],["Term variable",113,120,{"language-level":"0 term","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat-thms/add/add-0.ced - 155","symbol":"2 add-Z-1","type":"3 Π n : Nat . ((add n Z) ≃ n)","hnf of type":"4 Π n : Nat . ((add n Z) ≃ n)"}],["Punctuation",111,124,{"not-for-navigation":"0 true"}],["Sigma",87,106,{"language-level":"0 term","type":"1 ((x (λ p . S) Z) ≃ (add x Z))","explanation":"2 Swap the sides of the equation synthesized for the body of the of this term."}],["Application of a term to a term",91,103,{"language-level":"0 term","type":"1 ((add x Z) ≃ (x (λ p . S) Z))"}],["Term variable",102,103,{"language-level":"0 term","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat.ced - 57","symbol":"2 Z","expected-type":"3 Nat","type":"4 Nat"}],["Application of a term to a term",91,101,{"language-level":"0 term","type":"1 Π y : Nat . ((add x y) ≃ (x (λ p . S) y))"}],["Term variable",100,101,{"language-level":"0 term","location":"1 S-1.ced - 81","symbol":"2 x","expected-type":"3 Nat","type":"4 Nat"}],["Term variable",91,99,{"language-level":"0 term","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat-thms/add/add-0.ced - 28","symbol":"2 add-defn","type":"3 Π x : Nat . Π y : Nat . ((add x y) ≃ (x (λ p . S) y))","hnf of type":"4 Π x : Nat . Π y : Nat . ((add x y) ≃ (x (λ p . S) y))"}],["Punctuation",89,106,{"not-for-navigation":"0 true"}],["Term variable",81,82,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 x","type":"3 Nat","hnf of type":"4 Nat"}],["Lambda abstraction (term-level)",79,128,{"language-level":"0 term","binder":"1 0","type":"2 Π x : Nat . (x ≃ (x (λ p . S) Z))"}],["Punctuation",79,80,{"not-for-navigation":"0 true"}],["Equation",55,74,{"language-level":"0 type","kind":"1 ★"}],["Term variable",73,74,{"language-level":"0 term","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat.ced - 57","symbol":"2 Z"}],["Term variable",69,70,{"language-level":"0 term","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat.ced - 41","symbol":"2 S"}],["Term variable",59,60,{"language-level":"0 term","location":"1 S-1.ced - 45","symbol":"2 x"}],["Term variable",55,56,{"language-level":"0 term","location":"1 S-1.ced - 45","symbol":"2 x"}],["Term variable",45,46,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 x","type":"3 Nat","hnf of type":"4 Nat"}],["Type variable",49,52,{"language-level":"0 type","location":"1 /space/guneratne/cedille-stuff/cedille/lib/nat.ced - 35","symbol":"2 Nat","expected kind":"3 ★","kind":"4 ★"}],["Punctuation",43,44,{"not-for-navigation":"0 true"}],["Dependent function type",43,74,{"language-level":"0 type","binder":"1 0","kind":"2 ★"}],["Import of another source file",1,27,{"location":"0 /space/guneratne/cedille-stuff/cedille/lib/nat-thms/add/add-0.ced - 1"}]]}
