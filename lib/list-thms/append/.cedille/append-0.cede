{"spans":[["Cedille source file (/mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced)",1,364,{}],["Term-level definition (checking)",238,360,{"summary":"0 append-empty : ∀ A : ★ . Π l : (List · A) . ((append l (Nil · A)) ≃ l)","erasure":"1 λ l . (l (λ h . λ t . λ ih . β) β)"}],["Application of a term to a term",321,358,{"language-level":"0 term","expected-type":"1 ((append l Nil) ≃ l)","type":"2 ((append l Nil) ≃ l)"}],["Beta axiom",357,358,{"language-level":"0 term","explanation":"1 A term constant whose type states that β-equal terms are provably equal","type":"2 ((append Nil Nil) ≃ Nil)"}],["Application of a term to a term",321,356,{"language-level":"0 term","type":"1 ((λ l : (List · A) . ((append l Nil) ≃ l)) Nil) → ((λ l : (List · A) . ((append l Nil) ≃ l)) l)"}],["Rho",346,354,{"language-level":"0 term","the equation":"1 ((append t Nil) ≃ t)","type":"2 ((λ c . λ e' . (c h (t appendCons Nil) (t appendCons Nil c e'))) ≃ (Cons h t))","explanation":"3 Rewrite terms in the expected type, using an equation. "}],["Beta axiom",353,354,{"language-level":"0 term","explanation":"1 A term constant whose type states that β-equal terms are provably equal","type":"2 ((λ c . λ e' . (c h t (t c e'))) ≃ (Cons h t))"}],["Term variable",348,350,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 338","symbol":"2 ih","type":"3 (λ l : (List · A) . ((append l Nil) ≃ l)) t","hnf of type":"4 ((append t Nil) ≃ t)"}],["Epsilon",343,354,{"language-level":"0 term","type":"1 ((append (Cons h t) Nil) ≃ (Cons h t))","explanation":"2 Normalize the left-hand side of the expected equation, using head reduction."}],["Term variable",338,340,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 ih","type":"3 (λ l : (List · A) . ((append l Nil) ≃ l)) t","hnf of type":"4 ((append t Nil) ≃ t)"}],["Lambda abstraction (term-level)",336,354,{"language-level":"0 term","binder":"1 0","type":"2 ((λ l : (List · A) . ((append l Nil) ≃ l)) t) → ((λ l : (List · A) . ((append l Nil) ≃ l)) (Cons h t))"}],["Punctuation",336,337,{"not-for-navigation":"0 true"}],["Term variable",332,333,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 t","type":"3 List · A","hnf of type":"4 List · A"}],["Lambda abstraction (term-level)",330,354,{"language-level":"0 term","binder":"1 0","type":"2 Π t : (List · A) . (((λ l : (List · A) . ((append l Nil) ≃ l)) t) → ((λ l : (List · A) . ((append l Nil) ≃ l)) (Cons h t)))"}],["Punctuation",330,331,{"not-for-navigation":"0 true"}],["Term variable",326,327,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 h","type":"3 A","hnf of type":"4 A"}],["Lambda abstraction (term-level)",324,354,{"language-level":"0 term","binder":"1 0","type":"2 Π h : A . Π t : (List · A) . (((λ l : (List · A) . ((append l Nil) ≃ l)) t) → ((λ l : (List · A) . ((append l Nil) ≃ l)) (Cons h t)))"}],["Punctuation",324,325,{"not-for-navigation":"0 true"}],["Punctuation",323,356,{"not-for-navigation":"0 true"}],["Application of a term to a type",321,322,{"language-level":"0 term","type":"1 (Π h : A . Π t : (List · A) . (((λ l : (List · A) . ((append l Nil) ≃ l)) t) → ((λ l : (List · A) . ((append l Nil) ≃ l)) (Cons h t)))) → ((λ l : (List · A) . ((append l Nil) ≃ l)) Nil) → ((λ l : (List · A) . ((append l Nil) ≃ l)) l)"}],["Term variable",321,322,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 315","symbol":"2 l","type":"3 List · A","hnf of type":"4 List · A"}],["Theta",319,359,{"language-level":"0 term","expected-type":"1 ((append l Nil) ≃ l)","the motive":"2 λ l : (List · A) . ((append l Nil) ≃ l)","explanation":"3 Perform an elimination with the first term, after abstracting it from the expected type."}],["Term variable",315,316,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 l","type":"3 List · A","hnf of type":"4 List · A"}],["Lambda abstraction (term-level)",313,359,{"language-level":"0 term","binder":"1 0","type":"2 Π l : (List · A) . ((append l (Nil · A)) ≃ l)"}],["Punctuation",313,314,{"not-for-navigation":"0 true"}],["Type variable",309,310,{"language-level":"0 type","location":"1 missing - missing","symbol":"2 A","kind":"3 ★"}],["Erased lambda abstraction (term-level)",307,359,{"language-level":"0 term","binder":"1 0","type":"2 ∀ A : ★ . Π l : (List · A) . ((append l (Nil · A)) ≃ l)"}],["Punctuation",307,308,{"not-for-navigation":"0 true"}],["Equation",280,302,{"language-level":"0 type","kind":"1 ★"}],["Term variable",301,302,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 265","symbol":"2 l"}],["Term variable",290,293,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 87","symbol":"2 Nil"}],["Term variable",287,288,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 265","symbol":"2 l"}],["Term variable",280,286,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 397","symbol":"2 append"}],["Term variable",265,266,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 l","type":"3 List · A","hnf of type":"4 List · A"}],["Application of a type to a type",269,277,{"language-level":"0 type","expected kind":"1 ★","kind":"2 ★"}],["Type variable",276,277,{"language-level":"0 type","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 255","symbol":"2 A","expected kind":"3 ★","kind":"4 ★"}],["Type variable",269,273,{"language-level":"0 type","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 45","symbol":"2 List","kind":"3 ★ → ★"}],["Punctuation",263,264,{"not-for-navigation":"0 true"}],["Dependent function type",263,302,{"language-level":"0 type","binder":"1 0","kind":"2 ★"}],["Type variable",255,256,{"language-level":"0 type","location":"1 missing - missing","symbol":"2 A","kind":"3 ★"}],["Star",259,260,{"language-level":"0 kind"}],["Punctuation",253,254,{"not-for-navigation":"0 true"}],["Implicit dependent function type",253,302,{"language-level":"0 type","binder":"1 0","kind":"2 ★"}],["Term-level definition (checking)",15,235,{"summary":"0 append-assoc : ∀ A : ★ . Π x : (List · A) . Π y : (List · A) . Π z : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))","erasure":"1 λ x . λ y . λ z . (x (λ h . λ t . λ u . β) β)"}],["Application of a term to a term",190,233,{"language-level":"0 term","expected-type":"1 ((append (append x y) z) ≃ (append x (append y z)))","type":"2 ((append (append x y) z) ≃ (append x (append y z)))"}],["Beta axiom",232,233,{"language-level":"0 term","explanation":"1 A term constant whose type states that β-equal terms are provably equal","type":"2 ((append (append Nil y) z) ≃ (append Nil (append y z)))"}],["Application of a term to a term",190,231,{"language-level":"0 term","type":"1 ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) Nil) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) x)"}],["Rho",220,227,{"language-level":"0 term","the equation":"1 ((append (append t y) z) ≃ (append t (append y z)))","type":"2 ((λ c . λ e . (c h (t appendCons y appendCons z) (t appendCons y appendCons z c e))) ≃ (λ c . λ e' . (c h (t appendCons (append y z)) (t appendCons (append y z) c e'))))","explanation":"3 Rewrite terms in the expected type, using an equation. "}],["Beta axiom",226,227,{"language-level":"0 term","explanation":"1 A term constant whose type states that β-equal terms are provably equal","type":"2 ((λ c . λ e . (c h (append t (append y z)) (append t (append y z) c e))) ≃ (λ c . λ e' . (c h (t appendCons (append y z)) (t appendCons (append y z) c e'))))"}],["Term variable",222,223,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 207","symbol":"2 u","type":"3 (λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) t","hnf of type":"4 ((append (append t y) z) ≃ (append t (append y z)))"}],["Punctuation",219,228,{"not-for-navigation":"0 true"}],["Epsilon",216,228,{"language-level":"0 term","type":"1 ((λ c . λ e . (c h (t appendCons y appendCons z) (t appendCons y appendCons z c e))) ≃ (append (Cons h t) (append y z)))","explanation":"2 Normalize the right-hand side of the expected equation, using head reduction."}],["Punctuation",215,229,{"not-for-navigation":"0 true"}],["Epsilon",212,229,{"language-level":"0 term","type":"1 ((append (append (Cons h t) y) z) ≃ (append (Cons h t) (append y z)))","explanation":"2 Normalize the left-hand side of the expected equation, using head reduction."}],["Punctuation",211,230,{"not-for-navigation":"0 true"}],["Term variable",207,208,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 u","type":"3 (λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) t","hnf of type":"4 ((append (append t y) z) ≃ (append t (append y z)))"}],["Lambda abstraction (term-level)",205,230,{"language-level":"0 term","binder":"1 0","type":"2 ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) t) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) (Cons h t))"}],["Punctuation",205,206,{"not-for-navigation":"0 true"}],["Term variable",201,202,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 t","type":"3 List · A","hnf of type":"4 List · A"}],["Lambda abstraction (term-level)",199,230,{"language-level":"0 term","binder":"1 0","type":"2 Π t : (List · A) . (((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) t) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) (Cons h t)))"}],["Punctuation",199,200,{"not-for-navigation":"0 true"}],["Term variable",195,196,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 h","type":"3 A","hnf of type":"4 A"}],["Lambda abstraction (term-level)",193,230,{"language-level":"0 term","binder":"1 0","type":"2 Π h : A . Π t : (List · A) . (((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) t) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) (Cons h t)))"}],["Punctuation",193,194,{"not-for-navigation":"0 true"}],["Punctuation",192,231,{"not-for-navigation":"0 true"}],["Application of a term to a type",190,191,{"language-level":"0 term","type":"1 (Π h : A . Π t : (List · A) . (((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) t) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) (Cons h t)))) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) Nil) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) x)"}],["Term variable",190,191,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 168","symbol":"2 x","type":"3 List · A","hnf of type":"4 List · A"}],["Theta",188,234,{"language-level":"0 term","expected-type":"1 ((append (append x y) z) ≃ (append x (append y z)))","the motive":"2 λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))","explanation":"3 Perform an elimination with the first term, after abstracting it from the expected type."}],["Term variable",180,181,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 z","type":"3 List · A","hnf of type":"4 List · A"}],["Lambda abstraction (term-level)",178,234,{"language-level":"0 term","binder":"1 0","type":"2 Π z : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))"}],["Punctuation",178,179,{"not-for-navigation":"0 true"}],["Term variable",174,175,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 y","type":"3 List · A","hnf of type":"4 List · A"}],["Lambda abstraction (term-level)",172,234,{"language-level":"0 term","binder":"1 0","type":"2 Π y : (List · A) . Π z : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))"}],["Punctuation",172,173,{"not-for-navigation":"0 true"}],["Term variable",168,169,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 x","type":"3 List · A","hnf of type":"4 List · A"}],["Lambda abstraction (term-level)",166,234,{"language-level":"0 term","binder":"1 0","type":"2 Π x : (List · A) . Π y : (List · A) . Π z : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))"}],["Punctuation",166,167,{"not-for-navigation":"0 true"}],["Type variable",162,163,{"language-level":"0 type","location":"1 missing - missing","symbol":"2 A","kind":"3 ★"}],["Erased lambda abstraction (term-level)",160,234,{"language-level":"0 term","binder":"1 0","type":"2 ∀ A : ★ . Π x : (List · A) . Π y : (List · A) . Π z : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))"}],["Punctuation",160,161,{"not-for-navigation":"0 true"}],["Equation",106,155,{"language-level":"0 type","kind":"1 ★"}],["Term variable",152,153,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 76","symbol":"2 z"}],["Term variable",150,151,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 59","symbol":"2 y"}],["Term variable",143,149,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 397","symbol":"2 append"}],["Term variable",140,141,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 42","symbol":"2 x"}],["Term variable",133,139,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 397","symbol":"2 append"}],["Term variable",127,128,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 76","symbol":"2 z"}],["Term variable",124,125,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 59","symbol":"2 y"}],["Term variable",122,123,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 42","symbol":"2 x"}],["Term variable",115,121,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 397","symbol":"2 append"}],["Term variable",107,113,{"language-level":"0 term","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 397","symbol":"2 append"}],["Term variable",76,77,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 z","type":"3 List · A","hnf of type":"4 List · A"}],["Application of a type to a type",80,88,{"language-level":"0 type","expected kind":"1 ★","kind":"2 ★"}],["Type variable",87,88,{"language-level":"0 type","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 32","symbol":"2 A","expected kind":"3 ★","kind":"4 ★"}],["Type variable",80,84,{"language-level":"0 type","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 45","symbol":"2 List","kind":"3 ★ → ★"}],["Punctuation",74,75,{"not-for-navigation":"0 true"}],["Dependent function type",74,155,{"language-level":"0 type","binder":"1 0","kind":"2 ★"}],["Term variable",59,60,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 y","type":"3 List · A","hnf of type":"4 List · A"}],["Application of a type to a type",63,71,{"language-level":"0 type","expected kind":"1 ★","kind":"2 ★"}],["Type variable",70,71,{"language-level":"0 type","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 32","symbol":"2 A","expected kind":"3 ★","kind":"4 ★"}],["Type variable",63,67,{"language-level":"0 type","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 45","symbol":"2 List","kind":"3 ★ → ★"}],["Punctuation",57,58,{"not-for-navigation":"0 true"}],["Dependent function type",57,155,{"language-level":"0 type","binder":"1 0","kind":"2 ★"}],["Term variable",42,43,{"language-level":"0 term","location":"1 missing - missing","symbol":"2 x","type":"3 List · A","hnf of type":"4 List · A"}],["Application of a type to a type",46,54,{"language-level":"0 type","expected kind":"1 ★","kind":"2 ★"}],["Type variable",53,54,{"language-level":"0 type","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 32","symbol":"2 A","expected kind":"3 ★","kind":"4 ★"}],["Type variable",46,50,{"language-level":"0 type","location":"1 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 45","symbol":"2 List","kind":"3 ★ → ★"}],["Punctuation",40,41,{"not-for-navigation":"0 true"}],["Dependent function type",40,155,{"language-level":"0 type","binder":"1 0","kind":"2 ★"}],["Type variable",32,33,{"language-level":"0 type","location":"1 missing - missing","symbol":"2 A","kind":"3 ★"}],["Star",36,37,{"language-level":"0 kind"}],["Punctuation",30,31,{"not-for-navigation":"0 true"}],["Implicit dependent function type",30,155,{"language-level":"0 type","binder":"1 0","kind":"2 ★"}],["Import of another source file",1,13,{"location":"0 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 1"}]]}
