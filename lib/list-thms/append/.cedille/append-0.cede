{"spans":[["Cedille source file (/mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced)",1,364,{}],["Term-level definition (checking)",238,360,{"checking-mode":"0 checking","summary":"1 append-empty : ∀ A : ★ . Π l : (List · A) . ((append l (Nil · A)) ≃ l)","erasure":"2 λ l . (l (λ h . λ t . λ ih . β) β)"}],["Application of a term to a term",321,358,{"checking-mode":"0 checking","language-level":"1 term","expected-type":"2 ((append l Nil) ≃ l)","type":"3 ((append l Nil) ≃ l)"}],["Beta axiom",357,358,{"checking-mode":"0 checking","language-level":"1 term","explanation":"2 A term constant whose type states that β-equal terms are provably equal","type":"3 ((append Nil Nil) ≃ Nil)"}],["Application of a term to a term",321,356,{"checking-mode":"0 synthesizing","language-level":"1 term","type":"2 ((λ l : (List · A) . ((append l Nil) ≃ l)) Nil) → ((λ l : (List · A) . ((append l Nil) ≃ l)) l)"}],["Rho",346,354,{"language-level":"0 term","the equation":"1 ((append t Nil) ≃ t)","type":"2 ((λ c . λ e' . (c h (t appendCons Nil) (t appendCons Nil c e'))) ≃ (Cons h t))","explanation":"3 Rewrite terms in the expected type, using an equation. "}],["Beta axiom",353,354,{"checking-mode":"0 checking","language-level":"1 term","explanation":"2 A term constant whose type states that β-equal terms are provably equal","type":"3 ((λ c . λ e' . (c h t (t c e'))) ≃ (Cons h t))"}],["Term variable",348,350,{"checking-mode":"0 synthesizing","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 338","symbol":"3 ih","type":"4 (λ l : (List · A) . ((append l Nil) ≃ l)) t","hnf of type":"5 ((append t Nil) ≃ t)"}],["Epsilon",343,354,{"checking-mode":"0 checking","language-level":"1 term","type":"2 ((append (Cons h t) Nil) ≃ (Cons h t))","explanation":"3 Normalize the left-hand side of the expected equation, using head reduction."}],["Term variable",338,340,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 ih","type":"4 (λ l : (List · A) . ((append l Nil) ≃ l)) t","hnf of type":"5 ((append t Nil) ≃ t)"}],["Lambda abstraction (term-level)",336,354,{"language-level":"0 term","binder":"1 0","type":"2 ((λ l : (List · A) . ((append l Nil) ≃ l)) t) → ((λ l : (List · A) . ((append l Nil) ≃ l)) (Cons h t))"}],["Lambda",336,337,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Term variable",332,333,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 t","type":"4 List · A","hnf of type":"5 List · A"}],["Lambda abstraction (term-level)",330,354,{"language-level":"0 term","binder":"1 0","type":"2 Π t : (List · A) . (((λ l : (List · A) . ((append l Nil) ≃ l)) t) → ((λ l : (List · A) . ((append l Nil) ≃ l)) (Cons h t)))"}],["Lambda",330,331,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Term variable",326,327,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 h","type":"4 A","hnf of type":"5 A"}],["Lambda abstraction (term-level)",324,354,{"language-level":"0 term","binder":"1 0","type":"2 Π h : A . Π t : (List · A) . (((λ l : (List · A) . ((append l Nil) ≃ l)) t) → ((λ l : (List · A) . ((append l Nil) ≃ l)) (Cons h t)))"}],["Lambda",324,325,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Parens",323,356,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Application of a term to a type",321,322,{"checking-mode":"0 synthesizing","language-level":"1 term","type":"2 (Π h : A . Π t : (List · A) . (((λ l : (List · A) . ((append l Nil) ≃ l)) t) → ((λ l : (List · A) . ((append l Nil) ≃ l)) (Cons h t)))) → ((λ l : (List · A) . ((append l Nil) ≃ l)) Nil) → ((λ l : (List · A) . ((append l Nil) ≃ l)) l)"}],["Term variable",321,322,{"checking-mode":"0 synthesizing","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 315","symbol":"3 l","type":"4 List · A","hnf of type":"5 List · A"}],["Theta",319,359,{"language-level":"0 term","expected-type":"1 ((append l Nil) ≃ l)","the motive":"2 λ l : (List · A) . ((append l Nil) ≃ l)","explanation":"3 Perform an elimination with the first term, after abstracting it from the expected type."}],["Term variable",315,316,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 l","type":"4 List · A","hnf of type":"5 List · A"}],["Lambda abstraction (term-level)",313,359,{"language-level":"0 term","binder":"1 0","type":"2 Π l : (List · A) . ((append l (Nil · A)) ≃ l)"}],["Lambda",313,314,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Type variable",309,310,{"checking-mode":"0 checking","language-level":"1 type","location":"2 missing - missing","symbol":"3 A","kind":"4 ★"}],["Erased lambda abstraction (term-level)",307,359,{"language-level":"0 term","binder":"1 0","type":"2 ∀ A : ★ . Π l : (List · A) . ((append l (Nil · A)) ≃ l)"}],["Lambda",307,308,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Equation",280,302,{"checking-mode":"0 checking","language-level":"1 type","kind":"2 ★"}],["Term variable",301,302,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 265","symbol":"3 l"}],["Term variable",290,293,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 87","symbol":"3 Nil"}],["Term variable",287,288,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 265","symbol":"3 l"}],["Term variable",280,286,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 397","symbol":"3 append"}],["Term variable",265,266,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 l","type":"4 List · A","hnf of type":"5 List · A"}],["Application of a type to a type",269,277,{"checking-mode":"0 checking","language-level":"1 type","expected kind":"2 ★","kind":"3 ★"}],["Type variable",276,277,{"checking-mode":"0 checking","language-level":"1 type","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 255","symbol":"3 A","expected kind":"4 ★","kind":"5 ★"}],["Type variable",269,273,{"checking-mode":"0 synthesizing","language-level":"1 type","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 45","symbol":"3 List","kind":"4 ★ → ★"}],["Forall",263,264,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Dependent function type",263,302,{"checking-mode":"0 checking","language-level":"1 type","binder":"2 0","kind":"3 ★"}],["Type variable",255,256,{"checking-mode":"0 checking","language-level":"1 type","location":"2 missing - missing","symbol":"3 A","kind":"4 ★"}],["Star",259,260,{"checking-mode":"0 checking","language-level":"1 kind"}],["Forall",253,254,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Implicit dependent function type",253,302,{"checking-mode":"0 checking","language-level":"1 type","binder":"2 0","kind":"3 ★"}],["Term-level definition (checking)",15,235,{"checking-mode":"0 checking","summary":"1 append-assoc : ∀ A : ★ . Π x : (List · A) . Π y : (List · A) . Π z : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))","erasure":"2 λ x . λ y . λ z . (x (λ h . λ t . λ u . β) β)"}],["Application of a term to a term",190,233,{"checking-mode":"0 checking","language-level":"1 term","expected-type":"2 ((append (append x y) z) ≃ (append x (append y z)))","type":"3 ((append (append x y) z) ≃ (append x (append y z)))"}],["Beta axiom",232,233,{"checking-mode":"0 checking","language-level":"1 term","explanation":"2 A term constant whose type states that β-equal terms are provably equal","type":"3 ((append (append Nil y) z) ≃ (append Nil (append y z)))"}],["Application of a term to a term",190,231,{"checking-mode":"0 synthesizing","language-level":"1 term","type":"2 ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) Nil) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) x)"}],["Rho",220,227,{"language-level":"0 term","the equation":"1 ((append (append t y) z) ≃ (append t (append y z)))","type":"2 ((λ c . λ e . (c h (t appendCons y appendCons z) (t appendCons y appendCons z c e))) ≃ (λ c . λ e' . (c h (t appendCons (append y z)) (t appendCons (append y z) c e'))))","explanation":"3 Rewrite terms in the expected type, using an equation. "}],["Beta axiom",226,227,{"checking-mode":"0 checking","language-level":"1 term","explanation":"2 A term constant whose type states that β-equal terms are provably equal","type":"3 ((λ c . λ e . (c h (append t (append y z)) (append t (append y z) c e))) ≃ (λ c . λ e' . (c h (t appendCons (append y z)) (t appendCons (append y z) c e'))))"}],["Term variable",222,223,{"checking-mode":"0 synthesizing","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 207","symbol":"3 u","type":"4 (λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) t","hnf of type":"5 ((append (append t y) z) ≃ (append t (append y z)))"}],["Parens",219,228,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Epsilon",216,228,{"checking-mode":"0 checking","language-level":"1 term","type":"2 ((λ c . λ e . (c h (t appendCons y appendCons z) (t appendCons y appendCons z c e))) ≃ (append (Cons h t) (append y z)))","explanation":"3 Normalize the right-hand side of the expected equation, using head reduction."}],["Parens",215,229,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Epsilon",212,229,{"checking-mode":"0 checking","language-level":"1 term","type":"2 ((append (append (Cons h t) y) z) ≃ (append (Cons h t) (append y z)))","explanation":"3 Normalize the left-hand side of the expected equation, using head reduction."}],["Parens",211,230,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Term variable",207,208,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 u","type":"4 (λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) t","hnf of type":"5 ((append (append t y) z) ≃ (append t (append y z)))"}],["Lambda abstraction (term-level)",205,230,{"language-level":"0 term","binder":"1 0","type":"2 ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) t) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) (Cons h t))"}],["Lambda",205,206,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Term variable",201,202,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 t","type":"4 List · A","hnf of type":"5 List · A"}],["Lambda abstraction (term-level)",199,230,{"language-level":"0 term","binder":"1 0","type":"2 Π t : (List · A) . (((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) t) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) (Cons h t)))"}],["Lambda",199,200,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Term variable",195,196,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 h","type":"4 A","hnf of type":"5 A"}],["Lambda abstraction (term-level)",193,230,{"language-level":"0 term","binder":"1 0","type":"2 Π h : A . Π t : (List · A) . (((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) t) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) (Cons h t)))"}],["Lambda",193,194,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Parens",192,231,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Application of a term to a type",190,191,{"checking-mode":"0 synthesizing","language-level":"1 term","type":"2 (Π h : A . Π t : (List · A) . (((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) t) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) (Cons h t)))) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) Nil) → ((λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))) x)"}],["Term variable",190,191,{"checking-mode":"0 synthesizing","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 168","symbol":"3 x","type":"4 List · A","hnf of type":"5 List · A"}],["Theta",188,234,{"language-level":"0 term","expected-type":"1 ((append (append x y) z) ≃ (append x (append y z)))","the motive":"2 λ x : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))","explanation":"3 Perform an elimination with the first term, after abstracting it from the expected type."}],["Term variable",180,181,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 z","type":"4 List · A","hnf of type":"5 List · A"}],["Lambda abstraction (term-level)",178,234,{"language-level":"0 term","binder":"1 0","type":"2 Π z : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))"}],["Lambda",178,179,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Term variable",174,175,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 y","type":"4 List · A","hnf of type":"5 List · A"}],["Lambda abstraction (term-level)",172,234,{"language-level":"0 term","binder":"1 0","type":"2 Π y : (List · A) . Π z : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))"}],["Lambda",172,173,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Term variable",168,169,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 x","type":"4 List · A","hnf of type":"5 List · A"}],["Lambda abstraction (term-level)",166,234,{"language-level":"0 term","binder":"1 0","type":"2 Π x : (List · A) . Π y : (List · A) . Π z : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))"}],["Lambda",166,167,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Type variable",162,163,{"checking-mode":"0 checking","language-level":"1 type","location":"2 missing - missing","symbol":"3 A","kind":"4 ★"}],["Erased lambda abstraction (term-level)",160,234,{"language-level":"0 term","binder":"1 0","type":"2 ∀ A : ★ . Π x : (List · A) . Π y : (List · A) . Π z : (List · A) . ((append (append x y) z) ≃ (append x (append y z)))"}],["Lambda",160,161,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Equation",106,155,{"checking-mode":"0 checking","language-level":"1 type","kind":"2 ★"}],["Term variable",152,153,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 76","symbol":"3 z"}],["Term variable",150,151,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 59","symbol":"3 y"}],["Term variable",143,149,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 397","symbol":"3 append"}],["Term variable",140,141,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 42","symbol":"3 x"}],["Term variable",133,139,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 397","symbol":"3 append"}],["Term variable",127,128,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 76","symbol":"3 z"}],["Term variable",124,125,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 59","symbol":"3 y"}],["Term variable",122,123,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 42","symbol":"3 x"}],["Term variable",115,121,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 397","symbol":"3 append"}],["Term variable",107,113,{"checking-mode":"0 checking","language-level":"1 term","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 397","symbol":"3 append"}],["Term variable",76,77,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 z","type":"4 List · A","hnf of type":"5 List · A"}],["Application of a type to a type",80,88,{"checking-mode":"0 checking","language-level":"1 type","expected kind":"2 ★","kind":"3 ★"}],["Type variable",87,88,{"checking-mode":"0 checking","language-level":"1 type","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 32","symbol":"3 A","expected kind":"4 ★","kind":"5 ★"}],["Type variable",80,84,{"checking-mode":"0 synthesizing","language-level":"1 type","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 45","symbol":"3 List","kind":"4 ★ → ★"}],["Forall",74,75,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Dependent function type",74,155,{"checking-mode":"0 checking","language-level":"1 type","binder":"2 0","kind":"3 ★"}],["Term variable",59,60,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 y","type":"4 List · A","hnf of type":"5 List · A"}],["Application of a type to a type",63,71,{"checking-mode":"0 checking","language-level":"1 type","expected kind":"2 ★","kind":"3 ★"}],["Type variable",70,71,{"checking-mode":"0 checking","language-level":"1 type","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 32","symbol":"3 A","expected kind":"4 ★","kind":"5 ★"}],["Type variable",63,67,{"checking-mode":"0 synthesizing","language-level":"1 type","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 45","symbol":"3 List","kind":"4 ★ → ★"}],["Forall",57,58,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Dependent function type",57,155,{"checking-mode":"0 checking","language-level":"1 type","binder":"2 0","kind":"3 ★"}],["Term variable",42,43,{"checking-mode":"0 checking","language-level":"1 term","location":"2 missing - missing","symbol":"3 x","type":"4 List · A","hnf of type":"5 List · A"}],["Application of a type to a type",46,54,{"checking-mode":"0 checking","language-level":"1 type","expected kind":"2 ★","kind":"3 ★"}],["Type variable",53,54,{"checking-mode":"0 checking","language-level":"1 type","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list-thms/append/append-0.ced - 32","symbol":"3 A","expected kind":"4 ★","kind":"5 ★"}],["Type variable",46,50,{"checking-mode":"0 synthesizing","language-level":"1 type","location":"2 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 45","symbol":"3 List","kind":"4 ★ → ★"}],["Forall",40,41,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Dependent function type",40,155,{"checking-mode":"0 checking","language-level":"1 type","binder":"2 0","kind":"3 ★"}],["Type variable",32,33,{"checking-mode":"0 checking","language-level":"1 type","location":"2 missing - missing","symbol":"3 A","kind":"4 ★"}],["Star",36,37,{"checking-mode":"0 checking","language-level":"1 kind"}],["Forall",30,31,{"punctuation":"0 true","not-for-navigation":"1 true"}],["Implicit dependent function type",30,155,{"checking-mode":"0 checking","language-level":"1 type","binder":"2 0","kind":"3 ★"}],["Import of another source file",1,13,{"location":"0 /mnt/nfs/netapp2/grad/guneratne/cedille-stuff/cedille/lib/list.ced - 1"}]]}
