Index: src/classify.agda
===================================================================
--- src/classify.agda	(revision 27194)
+++ src/classify.agda	(working copy)
@@ -269,8 +269,8 @@
         cont (just tp) = get-ctxt (λ Γ → spanMr (just (hnf Γ unfold-head tp tt)))
         cont nothing = spanMr nothing 
 check-term subject (just tp) =
-  get-ctxt (λ Γ → 
-    check-termi subject (just (if is-intro-form subject then (hnf-instantiate-iota Γ subject tp ff) else (hnf Γ unfold-head tp tt))))
+  get-ctxt (λ Γ →
+    check-termi subject (just (if is-intro-form subject then (hnf-instantiate-iota Γ (qualif-term Γ subject) tp ff) else (hnf Γ unfold-head tp tt))))
 
 check-type subject nothing = check-typei subject nothing
 check-type subject (just k) = get-ctxt (λ Γ → check-typei subject (just (hnf Γ unfold-head k tt)))
@@ -307,7 +307,7 @@
   where cont : type → spanM (maybe type)
         cont (Abs pi b pi' x (Tkk k) tp2) = 
            check-type tp' (just k) ≫span 
-           get-ctxt (λ Γ → spanMr (just (subst-type Γ tp' x tp2)))
+           get-ctxt (λ Γ → spanMr (just (subst-type Γ (qualif-type Γ tp') x tp2)))
         cont tp'' =
           get-ctxt (λ Γ → 
             spanM-add (AppTp-span t tp' (maybe-to-checking tp)
@@ -329,7 +329,7 @@
         cont'' : maybe type → spanM (maybe type)
         cont'' nothing =
           spanM-add (AppTp-span t tp' (maybe-to-checking tp) []) ≫span spanMr nothing
-        cont'' (just htp) = get-ctxt (λ Γ → cont (hnf-instantiate-iota Γ t htp tt))
+        cont'' (just htp) = get-ctxt (λ Γ → cont (hnf-instantiate-iota Γ (qualif-term Γ t) htp tt))
 -- =BUG= =ACG= =31= Maybe pull out repeated code in helper functions?
 check-termi (App t m t') tp =
   check-term t nothing ≫=span cont'' ≫=spanr cont' tp 
@@ -350,7 +350,7 @@
           if check-term-app-matching-erasures m b then
              (check-term t' (just tp1) ≫span 
               get-ctxt (λ Γ → 
-                check-termi-return Γ (App t m t') (subst-type Γ t' x tp2)))
+                check-termi-return Γ (App t m t') (subst-type Γ (qualif-term Γ t') x tp2)))
           else
             check-term-app-erased-error (maybe-to-checking tp) m t t' (Abs pi b pi' x (Tkt tp1) tp2)
         cont m tp' =
@@ -378,7 +378,7 @@
                           (check-for-type-mismatch Γ "synthesized" tp tp' ++ hnf-expected-type-if Γ (just tp) [])))
         cont'' : maybe type → spanM (maybe type)
         cont'' nothing = spanM-add (App-span t t' (maybe-to-checking tp) []) ≫span spanMr nothing
-        cont'' (just htp) = get-ctxt (λ Γ → cont m (hnf-instantiate-iota Γ t htp tt))
+        cont'' (just htp) = get-ctxt (λ Γ → cont m (hnf-instantiate-iota Γ (qualif-term Γ t) htp tt))
 
 check-termi (Let pi d t) mtp =
   spanM-add (punctuation-span "Let" pi (posinfo-plus pi 3)) ≫span
@@ -454,7 +454,7 @@
   where this-span : ctxt → tk → optClass → 𝕃 tagged-val → span
         this-span Γ _ NoClass tvs = Lam-span Γ checking pi l x oc t tvs
         this-span Γ atk (SomeClass atk') tvs = 
-          if conv-tk Γ atk' atk then
+          if conv-tk Γ (qualif-tk Γ atk') atk then
             Lam-span Γ checking pi l x oc t tvs
           else
             Lam-span Γ checking pi l x oc t (lambda-bound-var-conv-error Γ x atk atk' tvs)
@@ -650,12 +650,13 @@
 
 check-termi (Chi pi (Atype tp) t) mtp = 
   check-type tp (just star) ≫span
-  check-term t (just tp) ≫span cont mtp
+  get-ctxt λ Γ →
+  check-term t (just (qualif-type Γ tp)) ≫span cont mtp
   where cont : (m : maybe type) → spanM (check-ret m)
         cont nothing = get-ctxt (λ Γ → spanM-add (Chi-span Γ pi (Atype tp) t synthesizing []) ≫span spanMr (just tp))
         cont (just tp') =
           get-ctxt (λ Γ → 
-           spanM-add (Chi-span Γ pi (Atype tp) t checking (check-for-type-mismatch Γ "asserted" tp' tp)))
+           spanM-add (Chi-span Γ pi (Atype tp) t checking (check-for-type-mismatch Γ "asserted" tp' (qualif-type Γ tp))))
 check-termi (Chi pi NoAtype t) (just tp) = 
   check-term t nothing ≫=span cont 
   where cont : (m : maybe type) → spanM ⊤
@@ -733,10 +734,13 @@
 check-termi (IotaPair pi t1 t2 ot pi') (just (IotaEx pi1 Iota pi2 x (SomeType tp1) tp2)) =
   check-term t1 (just tp1) ≫span
   get-ctxt (λ Γ → 
-    check-term t2 (just (subst-type Γ t1 x tp2)) ≫span
-    add-spans-if ot t1 t2 ≫span
+    let t1' = qualif-term Γ t1 in
+    let t2' = qualif-term Γ t2 in
+    check-term t2 (just (subst-type Γ t1' x tp2)) ≫span
+    add-spans-if ot t1' t2' ≫span
+    -- TODO why another get-ctxt here?
     get-ctxt (λ Γ → 
-    spanM-add (IotaPair-span pi pi' checking (expected-type Γ (IotaEx pi1 Iota pi2 x (SomeType tp1) tp2) :: (check-conv-if Γ ot t1 t2)))))
+    spanM-add (IotaPair-span pi pi' checking (expected-type Γ (IotaEx pi1 Iota pi2 x (SomeType tp1) tp2) :: (check-conv-if Γ ot t1' t2')))))
   where err : ctxt → string → term → tagged-val
         err Γ which t = ("Hnf of the " ^ which ^ " component: ") , term-to-string Γ tt (hnf Γ unfold-head t tt)
         add-spans-if : optTerm → term → term → spanM ⊤
@@ -831,7 +835,7 @@
    check-tk atk ≫span
    spanM-add (punctuation-span "Lambda (type)" pi (posinfo-plus pi 1)) ≫span
    get-ctxt (λ Γ → 
-   spanM-add (if conv-tk Γ atk atk' then
+   spanM-add (if conv-tk Γ (qualif-tk Γ atk) atk' then
                 TpLambda-span pi x atk body checking [ kind-data Γ k ]
               else
                 TpLambda-span pi x atk body checking (lambda-bound-var-conv-error Γ x atk' atk [ kind-data Γ k ])) ≫span
@@ -892,7 +896,7 @@
         cont (KndPi _ _ x (Tkt tp') k') = 
           check-term t (just tp') ≫span 
           get-ctxt (λ Γ → 
-            spanMr (just (subst-kind Γ t x k')))
+            spanMr (just (subst-kind Γ (qualif-term Γ t) x k')))
         cont k' = get-ctxt (λ Γ → 
                    spanM-add (TpAppt-span tp t (maybe-to-checking k)
                                (error-data ("The kind computed for the head of the type application does"
@@ -928,7 +932,7 @@
         cont (KndPi _ _ x (Tkk k'') k') = 
           check-type tp' (just k'') ≫span 
           get-ctxt (λ Γ → 
-            spanMr (just (subst-kind Γ tp' x k')))
+            spanMr (just (subst-kind Γ (qualif-type Γ tp') x k')))
         cont k' = get-ctxt (λ Γ → 
                   spanM-add (TpApp-span tp tp' (maybe-to-checking k)
                                (error-data ("The kind computed for the head of the type application does"
@@ -1002,7 +1006,7 @@
   check-kind k
 check-kind (Star pi) = spanM-add (Star-span pi checking)
 check-kind (KndVar pi x ys) =
-  get-ctxt (λ Γ → helper (ctxt-lookup-kind-var-def Γ x) ys)
+  get-ctxt (λ Γ → helper (ctxt-lookup-kind-var-qdef Γ x) ys)
   where helper : maybe (params × kind) → args → spanM ⊤
         helper (just (ps , k)) ys =
           check-args-against-params ps ys ≫=span λ m →
Index: src/conversion.agda
===================================================================
--- src/conversion.agda	(revision 27194)
+++ src/conversion.agda	(working copy)
@@ -185,6 +185,8 @@
 hnf{KIND} Γ u x hd = x
 
 hnf{LIFTINGTYPE} Γ u x hd = x
+hnf{QUALIF} Γ u x hd = x
+hnf{ARG} Γ u x hd = x
 
 hnf-tk Γ u (Tkk k) = Tkk (hnf Γ u k tt)
 hnf-tk Γ u (Tkt tp) = Tkt (hnf Γ u tp ff)
@@ -289,3 +291,11 @@
 conv-tty* Γ (ttype t :: args) (ttype t' :: args') = conv-type Γ t t' && conv-tty* Γ args args'
 conv-tty* Γ _ _ = ff
 
+hnf-qualif-term : ctxt → term → term
+hnf-qualif-term Γ t = hnf Γ unfold-head (qualif-term Γ t) tt
+
+hnf-qualif-type : ctxt → type → type
+hnf-qualif-type Γ t = hnf Γ unfold-head (qualif-type Γ t) tt
+
+hnf-qualif-kind : ctxt → kind → kind
+hnf-qualif-kind Γ t = hnf Γ unfold-head (qualif-kind Γ t) tt
Index: src/ctxt.agda
===================================================================
--- src/ctxt.agda	(revision 27194)
+++ src/ctxt.agda	(working copy)
@@ -2,73 +2,11 @@
 
 open import lib
 open import cedille-types
+open import ctxt-types public
+open import subst
 open import general-util
 open import syntax-util
 
-location : Set
-location = string × posinfo -- file path and starting position in the file 
-
-{- we will generally keep classifiers of variables in hnf in the ctxt, although
-   we will not necessarily unfold recursive type definitions. -}
-
-defScope : Set
-defScope = 𝔹
-
-localScope : defScope
-localScope = tt
-
-globalScope : defScope
-globalScope = ff
-
-defParams : Set
-defParams = maybe params
-
-data ctxt-info : Set where
-
-  -- for declaring a variable to have a given type (with no definition)
-  term-decl : type → ctxt-info
-
-  -- for defining a variable to equal a term with a given type
-  term-def : defParams → term → type → ctxt-info
-
-  -- for untyped term definitions 
-  term-udef : defParams → term → ctxt-info
-
-  -- for declaring a variable to have a given kind (with no definition)
-  type-decl : kind → ctxt-info
-
-  -- for defining a variable to equal a type with a given kind
-  type-def : defParams → type → kind → ctxt-info
-
-  -- for defining a variable to equal a kind
-  kind-def : params → params → kind → ctxt-info
-
-  -- to rename a variable at any level to another
-  rename-def : var → ctxt-info
-
-  -- representing a declaration of a variable with no other information about it
-  var-decl : ctxt-info
-
-sym-info : Set
-sym-info = ctxt-info × location
-
--- module filename, parameters, and qualifying substitution
-mod-info : Set
-mod-info = string × params × qualif
-
-is-term-level : ctxt-info → 𝔹
-is-term-level (term-decl _) = tt
-is-term-level (term-def _ _ _) = tt
-is-term-level (term-udef _ _) = tt
-is-term-level _ = ff
-
-data ctxt : Set where
-  mk-ctxt : (mod : mod-info) →                     -- current module
-            (syms : trie (𝕃 string)) →             -- map each filename to the symbols declared in that file
-            (i : trie sym-info) →                  -- map symbols (from Cedille files) to their ctxt-info and location
-            (sym-occurrences : trie (𝕃 (var × posinfo × string))) →  -- map symbols to a list of definitions they occur in (and relevant file info)
-            ctxt
-
 new-ctxt : (filename : string) → ctxt
 new-ctxt fn = mk-ctxt (fn , ParamsNil , empty-trie) empty-trie empty-trie empty-trie
 
@@ -84,51 +22,68 @@
 ctxt-restore-info* Γ ((x , m) :: ms) = ctxt-restore-info* (ctxt-restore-info Γ x m) ms
 
 ctxt-term-decl : posinfo → var → type → ctxt → ctxt
-ctxt-term-decl p v t (mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt (fn , ps , q)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (term-decl t , (fn , p)))
-                                                    symb-occs
+ctxt-term-decl p v t (mk-ctxt (fn , ps , q) syms i symb-occs) =
+  mk-ctxt (fn , ps , q) syms (trie-insert i v (term-decl t , (fn , p))) symb-occs
 
 ctxt-type-decl : posinfo → var → kind → ctxt → ctxt
-ctxt-type-decl p v k (mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt (fn , ps , q)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (type-decl k , (fn , p)))
-                                                    symb-occs
+ctxt-type-decl p v k (mk-ctxt (fn , ps , q) syms i symb-occs) =
+  mk-ctxt (fn , ps , q) syms (trie-insert i v (type-decl k , (fn , p))) symb-occs
 
 def-params : defScope → params → defParams
 def-params tt ps = nothing
 def-params ff ps = just ps
 
--- TODO roll "hnf Γ unfold-head t tt" into ctxt-*-def, after qualification
-ctxt-type-def : posinfo → defScope → var → type → kind → ctxt → ctxt
-ctxt-type-def p s v t k (mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt (fn , ps , qualif-insert-params q fn v ps)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (type-def (def-params s ps) (qualif-type q t) (qualif-kind q k) , (fn , p)))
-                                                    symb-occs
+-- TODO add renamectxt to avoid capture bugs
+inst-type : ctxt → params → args → type → type
+inst-type Γ ps as = substs-type Γ (mk-inst ps as)
+
+inst-kind : ctxt → params → args → kind → kind
+inst-kind Γ ps as = substs-kind Γ (mk-inst ps as)
+
+-- TODO substs-params
+inst-params : ctxt → params → args → params → params
+inst-params Γ ps as qs = qs
+
+qualif-term : ctxt → term → term
+qualif-term Γ@(mk-ctxt (_ , _ , σ) _ _ _) = substs-term Γ σ
+
+qualif-type : ctxt → type → type
+qualif-type Γ@(mk-ctxt (_ , _ , σ) _ _ _) = substs-type Γ σ
+
+qualif-kind : ctxt → kind → kind
+qualif-kind Γ@(mk-ctxt (_ , _ , σ) _ _ _) = substs-kind Γ σ
+
+qualif-tk : ctxt → tk → tk
+qualif-tk Γ (Tkt t) = Tkt (qualif-type Γ t)
+qualif-tk Γ (Tkk k) = Tkk (qualif-kind Γ k)
 
 ctxt-kind-def : posinfo → var → params → kind → ctxt → ctxt
-ctxt-kind-def p v ps2 k (mk-ctxt (fn , ps1 , q) syms i symb-occs) = mk-ctxt (fn , ps1 , qualif-insert-params q fn v ps1)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (kind-def ps1 ps2 k , (fn , p)))
-                                                    symb-occs
+ctxt-kind-def p v ps2 k (mk-ctxt (fn , ps1 , q) syms i symb-occs) = mk-ctxt
+  (fn , ps1 , qualif-insert-params q fn v ps1)
+  (trie-insert-append syms fn v)
+  (trie-insert i (fn # v) (kind-def ps1 ps2 k , (fn , p)))
+  symb-occs
+
+ctxt-type-def : posinfo → defScope → var → type → kind → ctxt → ctxt
+ctxt-type-def p s v t k Γ@(mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt
+  (fn , ps , qualif-insert-params q fn v ps)
+  (trie-insert-append syms fn v)
+  (trie-insert i (fn # v) (type-def (def-params s ps) t k , (fn , p)))
+  symb-occs
 
 ctxt-term-def : posinfo → defScope → var → term → type → ctxt → ctxt
-ctxt-term-def p s v t tp (mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt (fn , ps , qualif-insert-params q fn v ps)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (term-def (def-params s ps) (qualif-term q t) (qualif-type q tp) , (fn , p)))
-                                                    symb-occs
+ctxt-term-def p s v t tp Γ@(mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt
+  (fn , ps , qualif-insert-params q fn v ps)
+  (trie-insert-append syms fn v)
+  (trie-insert i (fn # v) (term-def (def-params s ps) t tp , (fn , p)))
+  symb-occs
 
 ctxt-term-udef : posinfo → defScope → var → term → ctxt → ctxt
-ctxt-term-udef p s v t (mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt (fn , ps , qualif-insert-params q fn v ps)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (term-udef (def-params s ps) (qualif-term q t) , (fn , p)))
-                                                    symb-occs
-
-ctxt-var-decl : posinfo → var → ctxt → ctxt
-ctxt-var-decl p v (mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt (fn , ps , q)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (var-decl , (fn , p)))
-                                                    symb-occs
+ctxt-term-udef p s v t Γ@(mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt
+  (fn , ps , qualif-insert-params q fn v ps)
+  (trie-insert-append syms fn v)
+  (trie-insert i (fn # v) (term-udef (def-params s ps) t , (fn , p)))
+  symb-occs
 
 -- TODO not sure how this and renaming interacts with module scope
 ctxt-var-decl-if : posinfo → var → ctxt → ctxt
@@ -136,7 +91,9 @@
 ... | mk-ctxt (fn , ps , q) syms i symb-occs with trie-lookup i v
 ... | just (rename-def _ , _) = Γ
 ... | just (var-decl , _) = Γ
-... | _ = mk-ctxt (fn , ps , q) (trie-insert-append syms fn v)
+... | _ = mk-ctxt
+  (fn , ps , q)
+  syms
   (trie-insert i v (var-decl , (fn , p)))
   symb-occs
 
@@ -152,10 +109,10 @@
 {- add a renaming mapping the first variable to the second, unless they are equal.
    Notice that adding a renaming for v will overwrite any other declarations for v. -}
 ctxt-rename : posinfo → var → var → ctxt → ctxt
-ctxt-rename p v v' (mk-ctxt (fn , ps , q) syms i symb-occs) = 
-  (mk-ctxt (fn , ps , q) (trie-insert-append syms fn v)
-      (trie-insert i v (rename-def v' , (fn , p)))
-      symb-occs)
+ctxt-rename p v v' (mk-ctxt (fn , ps , q) syms i symb-occs) =
+  mk-ctxt (fn , ps , q) syms
+    (trie-insert i v (rename-def v' , (fn , p)))
+    symb-occs
 
 ctxt-tk-decl : posinfo → var → tk → ctxt → ctxt
 ctxt-tk-decl p x (Tkt t) Γ = ctxt-term-decl p x t Γ 
@@ -168,49 +125,59 @@
 -- look for a defined kind for the given var, which is assumed to be a type,
 -- then instantiate its parameters
 env-lookup-type-var : ctxt → var → args → maybe kind
-env-lookup-type-var (mk-ctxt _ _ i _) v as with trie-lookup i v
-... | just (type-def (just ps) _ k , _) = just (inst-kind ps as k)
+env-lookup-type-var Γ@(mk-ctxt _ _ i _) v as with trie-lookup i v
+... | just (type-def (just ps) _ k , _) = just (inst-kind Γ ps as k)
 ... | _ = nothing
 
 -- look for a declared kind for the given var, which is assumed to be a type,
 -- otherwise look for a qualified defined kind
 ctxt-lookup-type-var : ctxt → var → maybe kind
 ctxt-lookup-type-var Γ@(mk-ctxt (_ , _ , q) _ i _) v with trie-lookup i v
-... | just (type-decl k , _) = just (qualif-kind q k)
-... | just (type-def nothing _ k , _) = just (qualif-kind q k)
+... | just (type-decl k , _) = just (qualif-kind Γ k)
+... | just (type-def nothing _ k , _) = just (qualif-kind Γ k)
 ... | _ with trie-lookup q v
 ... | just (v' , as) = env-lookup-type-var Γ v' as
 ... | _ = nothing
 
 env-lookup-term-var : ctxt → var → args → maybe type
-env-lookup-term-var (mk-ctxt _ _ i _) v as with trie-lookup i v
-... | just (term-def (just ps) _ t , _) = just (inst-type ps as t)
+env-lookup-term-var Γ@(mk-ctxt _ _ i _) v as with trie-lookup i v
+... | just (term-def (just ps) _ t , _) = just (inst-type Γ ps as t)
 ... | _ = nothing
 
 ctxt-lookup-term-var : ctxt → var → maybe type
 ctxt-lookup-term-var Γ@(mk-ctxt (_ , _ , q) _ i _) v with trie-lookup i v
-... | just (term-decl t , _) = just (qualif-type q t)
-... | just (term-def nothing _ t , _) = just (qualif-type q t)
+... | just (term-decl t , _) = just (qualif-type Γ t)
+... | just (term-def nothing _ t , _) = just (qualif-type Γ t)
 ... | _ with trie-lookup q v
 ... | just (v' , as) = env-lookup-term-var Γ v' as
 ... | _ = nothing
 
 env-lookup-tk-var : ctxt → var → args → maybe tk
-env-lookup-tk-var (mk-ctxt _ _ i _) v as with trie-lookup i v
-... | just (type-def (just ps) _ k , _) = just (Tkk (inst-kind ps as k))
-... | just (term-def (just ps) _ t , _) = just (Tkt (inst-type ps as t))
+env-lookup-tk-var Γ@(mk-ctxt _ _ i _) v as with trie-lookup i v
+... | just (type-def (just ps) _ k , _) = just (Tkk (inst-kind Γ ps as k))
+... | just (term-def (just ps) _ t , _) = just (Tkt (inst-type Γ ps as t))
 ... | _ = nothing
 
 ctxt-lookup-tk-var : ctxt → var → maybe tk
 ctxt-lookup-tk-var Γ@(mk-ctxt (_ , _ , q) _ i _) v with trie-lookup i v
-... | just (type-decl k , _) = just (Tkk (qualif-kind q k))
-... | just (type-def nothing _ k , _) = just (Tkk (qualif-kind q k))
-... | just (term-decl t , _) = just (Tkt (qualif-type q t))
-... | just (term-def nothing _ t , _) = just (Tkt (qualif-type q t))
+... | just (type-decl k , _) = just (Tkk (qualif-kind Γ k))
+... | just (type-def nothing _ k , _) = just (Tkk (qualif-kind Γ k))
+... | just (term-decl t , _) = just (Tkt (qualif-type Γ t))
+... | just (term-def nothing _ t , _) = just (Tkt (qualif-type Γ t))
 ... | _ with trie-lookup q v
 ... | just (v' , as) = env-lookup-tk-var Γ v' as
 ... | _ = nothing
 
+env-lookup-kind-var-qdef : ctxt → var → args → maybe (params × kind)
+env-lookup-kind-var-qdef Γ@(mk-ctxt _ _ i _) v as with trie-lookup i v
+... | just (kind-def ps1 ps2 k , _) = just (inst-params Γ ps1 as ps2 , inst-kind Γ ps1 as k)
+... | _ = nothing
+
+ctxt-lookup-kind-var-qdef : ctxt → var → maybe (params × kind)
+ctxt-lookup-kind-var-qdef Γ@(mk-ctxt (_ , _ , q) _ i _) v with trie-lookup q v
+... | just (v' , as) = env-lookup-kind-var-qdef Γ v' as
+... | _ = nothing
+
 ctxt-lookup-term-var-def : ctxt → var → maybe term
 ctxt-lookup-term-var-def (mk-ctxt _ _ i _) v with trie-lookup i v
 ... | just (term-def nothing t _ , _) = just t
@@ -227,12 +194,9 @@
 
 ctxt-lookup-kind-var-def : ctxt → var → maybe (params × kind)
 ctxt-lookup-kind-var-def (mk-ctxt _ _ i _) x with trie-lookup i x
-... | just (kind-def _ ps k , _) = just (ps , k)
+... | just (kind-def ps1 ps2 k , _) = just (append-params ps1 ps2 , k)
 ... | _ = nothing
 
-ctxt-binds-var : ctxt → var → 𝔹
-ctxt-binds-var (mk-ctxt (_ , _ , q) _ i _) x = trie-contains q x || trie-contains i x
-
 ctxt-lookup-occurrences : ctxt → var → 𝕃 (var × posinfo × string)
 ctxt-lookup-occurrences (mk-ctxt _ _ _ symb-occs) symbol with trie-lookup symb-occs symbol
 ... | just l = l
@@ -251,6 +215,7 @@
 ctxt-set-current-mod : ctxt → mod-info → ctxt
 ctxt-set-current-mod (mk-ctxt _ syms i symb-occs) m = mk-ctxt m syms i symb-occs
 
+-- TODO I think this should trie-remove the List occurrence of the filename lookup of syms
 ctxt-clear-symbol : ctxt → string → ctxt
 ctxt-clear-symbol (mk-ctxt f syms i symb-occs) x = mk-ctxt f (trie-remove syms x) (trie-remove i x) symb-occs
 
@@ -260,11 +225,11 @@
 
 ctxt-clear-symbols-of-file : ctxt → (filename : string) → ctxt
 ctxt-clear-symbols-of-file (mk-ctxt f syms i symb-occs) fn = mk-ctxt f (trie-insert syms fn [])
-                                                                  (hremove i (trie-lookup𝕃 syms fn))
+                                                                  (hremove i fn (trie-lookup𝕃 syms fn))
                                                                   symb-occs
-  where hremove : ∀ {A : Set} → trie A → 𝕃 string → trie A
-        hremove i [] = i
-        hremove i (x :: xs) = hremove (trie-remove i x) xs
+  where hremove : ∀ {A : Set} → trie A → var → 𝕃 string → trie A
+        hremove i fn [] = i
+        hremove i fn (x :: xs) = hremove (trie-remove i (fn # x)) fn xs
 
 ctxt-initiate-file : ctxt → (filename : string) → ctxt
 ctxt-initiate-file Γ fn = ctxt-set-current-file (ctxt-clear-symbols-of-file Γ fn) fn
Index: src/general-util.agda
===================================================================
--- src/general-util.agda	(revision 27194)
+++ src/general-util.agda	(working copy)
@@ -25,7 +25,7 @@
 trie-lookupd t s d | just x = x
 
 trie-lookup-else : ∀{A : Set} → A → trie A → string → A
-trie-lookup-else x t s = trie-lookupd t s x
+trie-lookup-else d t s = trie-lookupd t s d
 
 trie-single : ∀{A : Set} → string → A → trie A
 trie-single s x = trie-insert empty-trie s x
Index: src/is-free.agda
===================================================================
--- src/is-free.agda	(revision 27194)
+++ src/is-free.agda	(working copy)
@@ -3,7 +3,7 @@
 open import lib
 
 open import cedille-types
-open import ctxt
+open import ctxt-types
 open import syntax-util
 
 is-free-e = 𝔹
@@ -105,10 +105,13 @@
 is-free-in-maybeAtype ce x (Atype T) = is-free-in-type ce x T
 
 is-free-in : {ed : exprd} → is-free-e → var → ⟦ ed ⟧ → 𝔹
-is-free-in{TERM} e x t = is-free-in-term e x t 
+is-free-in{TERM} e x t = is-free-in-term e x t
+is-free-in{ARG} e x (TermArg t) = is-free-in-term e x t
 is-free-in{TYPE} e x t = is-free-in-type e x t 
+is-free-in{ARG} e x (TypeArg t) = is-free-in-type e x t
 is-free-in{KIND} e x t = is-free-in-kind e x t 
 is-free-in{LIFTINGTYPE} e x t = is-free-in-liftingType e x t 
+is-free-in{QUALIF} e x (x' , as) = x =string x' || is-free-in-args e x as
 
 abs-tk : lam → var → tk → type → type
 abs-tk l x (Tkk k) tp = Abs posinfo-gen All posinfo-gen x (Tkk k) tp
Index: src/process-cmd.agda
===================================================================
--- src/process-cmd.agda	(revision 27194)
+++ src/process-cmd.agda	(working copy)
@@ -42,28 +42,33 @@
 
 process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Γ) (DefTermOrType (DefTerm pi x (Type tp) t) pi') tt {- check -} = 
   set-ctxt Γ ≫span
-  check-type tp (just star) ≫span 
-  check-term t (just tp) ≫span 
+  check-type tp (just star) ≫span
+  let tp' = qualif-type Γ tp in
+  check-term t (just tp') ≫span 
   get-ctxt (λ Γ → 
     let t = erase-term t in
-    let Γ' = (ctxt-term-def pi globalScope x (hnf Γ unfold-head t tt) tp Γ) in
+    let t' = hnf-qualif-term Γ t in
+    let Γ' = ctxt-term-def pi globalScope x t' tp' Γ in
       spanM-add (DefTerm-span Γ pi x checking (just tp) t pi' []) ≫span
       check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Γ)
         (spanM-add (Var-span Γ' pi x checking []) ≫span
          spanMr (mk-toplevel-state use-cede make-rkt ip fns is Γ')))
 
-process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Γ) (DefTermOrType (DefTerm pi x (Type tp) t) pi') ff {- skip checking -} = 
+process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Γ) (DefTermOrType (DefTerm pi x (Type tp) t) pi') ff {- skip checking -} =
+  let tp' = qualif-type Γ tp in
+  let t' = hnf-qualif-term Γ t in
     check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Γ)
-      (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (ctxt-term-def pi globalScope x (hnf Γ unfold-head t tt) tp Γ)))
+      (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (ctxt-term-def pi globalScope x t' tp' Γ)))
 
 process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Γ) (DefTermOrType (DefTerm pi x NoCheckType t) pi') _ = 
   set-ctxt Γ ≫span
   check-term t nothing ≫=span λ mtp → 
   get-ctxt (λ Γ → 
     let t = erase-term t in
+    let t' = hnf-qualif-term Γ t in
       spanM-add (DefTerm-span Γ pi x synthesizing mtp t pi' []) ≫span
       check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Γ)
-        (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (h Γ (hnf Γ unfold-head t tt , mtp)))))
+        (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (h Γ (t' , mtp)))))
   where h : ctxt → term × (maybe type) → ctxt
         h Γ (t , nothing) = ctxt-term-udef pi globalScope x t Γ
         h Γ (t , just tp) = ctxt-term-def pi globalScope x t tp Γ
@@ -71,24 +76,30 @@
 process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Γ) (DefTermOrType (DefType pi x k tp) pi') tt {- check -} =
     set-ctxt Γ ≫span
     check-kind k ≫span 
-    check-type tp (just k) ≫span 
+    let k' = qualif-kind Γ k in
+    check-type tp (just k') ≫span 
     get-ctxt (λ Γ → 
-      let Γ' = (ctxt-type-def pi globalScope x (hnf Γ unfold-head tp tt) k Γ) in
+      let tp' = hnf-qualif-type Γ tp in
+      let Γ' = ctxt-type-def pi globalScope x tp' k' Γ in
         spanM-add (DefType-span Γ pi x checking (just k) tp pi' []) ≫span
         check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Γ)
           (spanM-add (TpVar-span Γ' pi x checking []) ≫span
            spanMr (mk-toplevel-state use-cede make-rkt ip fns is Γ')))
 
 process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Γ) (DefTermOrType (DefType pi x k tp) pi') ff {- skip checking -} = 
-  check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Γ)
-    (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (ctxt-type-def pi globalScope x (hnf Γ unfold-head tp tt) k Γ)))
+  let k' = qualif-kind Γ k in
+  let tp' = hnf-qualif-type Γ tp in
+    check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Γ)
+      (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (ctxt-type-def pi globalScope x tp' k' Γ)))
 
 process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Γ) (DefKind pi x ps k pi') tt {- check -} =
   set-ctxt Γ ≫span
   check-and-add-params pi' ps ≫=span λ ms → 
   check-kind k ≫span
   get-ctxt (λ Γ → 
-    let Γ' = (ctxt-kind-def pi x ps (hnf Γ unfold-head k tt) Γ) in
+    let k' = hnf-qualif-kind Γ k in
+    -- TODO maybe need to qualif params ps
+    let Γ' = ctxt-kind-def pi x ps k' Γ in
       spanM-add (DefKind-span Γ pi x k pi') ≫span
       check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Γ)
        (spanM-add (KndVar-span Γ' pi x (ArgsNil (posinfo-plus-str pi x)) checking []) ≫span
@@ -104,8 +115,9 @@
         check-and-add-params _ ParamsNil = spanMr []
 
 process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Γ) (DefKind pi x ps k pi') ff {- skip checking -} = 
-  check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Γ)
-    (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (ctxt-kind-def pi x ps (hnf Γ unfold-head k tt) Γ)))
+  let k' = hnf-qualif-kind Γ k in
+    check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Γ)
+      (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (ctxt-kind-def pi x ps k' Γ)))
 
 process-cmd s (Import pi x pi') _ = 
   let cur-file = ctxt-get-current-filename (toplevel-state.Γ s) in
Index: src/rename.agda
===================================================================
--- src/rename.agda	(revision 27194)
+++ src/rename.agda	(working copy)
@@ -3,7 +3,7 @@
 open import lib
 
 open import cedille-types 
-open import ctxt
+open import ctxt-types
 open import is-free
 open import syntax-util
 
Index: src/subst.agda
===================================================================
--- src/subst.agda	(revision 27194)
+++ src/subst.agda	(working copy)
@@ -3,7 +3,7 @@
 open import lib
 
 open import cedille-types
-open import ctxt
+open import ctxt-types
 open import is-free
 open import rename
 open import general-util
@@ -53,6 +53,12 @@
 substh-term{TERM} Γ ρ σ (Var pi x) =
  let x' = renamectxt-rep ρ x in
    trie-lookup-else (Var pi x') σ x'
+substh-term{ARG} Γ ρ σ (Var pi x) =
+ let x' = renamectxt-rep ρ x in
+   inst-lookup-term pi σ x'
+substh-term{QUALIF} Γ ρ σ (Var pi x) =
+ let x' = renamectxt-rep ρ x in
+   qualif-lookup-term pi σ x'
 substh-term Γ ρ σ (Var pi x) = Var pi (renamectxt-rep ρ x)
 substh-term Γ ρ σ (Unfold pi t) = Unfold pi (substh-term Γ ρ σ t)
 substh-term Γ ρ σ (Beta pi ot) = Beta pi (substh-optTerm Γ ρ σ ot)
@@ -95,6 +101,12 @@
 substh-type{TYPE} Γ ρ σ (TpVar pi x) =
  let x' = renamectxt-rep ρ x in
    trie-lookup-else (TpVar pi x') σ x'
+substh-type{ARG} Γ ρ σ (TpVar pi x) =
+ let x' = renamectxt-rep ρ x in
+   inst-lookup-type pi σ x'
+substh-type{QUALIF} Γ ρ σ (TpVar pi x) =
+ let x' = renamectxt-rep ρ x in
+   qualif-lookup-type pi σ x'
 substh-type Γ ρ σ (TpVar pi x) = TpVar pi (renamectxt-rep ρ x)
 substh-type Γ ρ σ (TpHole pi) = TpHole pi --ACG
 substh-kind Γ ρ σ (KndArrow k k₁) = KndArrow (substh-kind Γ ρ σ k) (substh-kind Γ ρ σ k₁)
@@ -104,6 +116,8 @@
     KndPi pi pi' x' (substh-tk Γ ρ σ atk)
       (substh-kind (ctxt-var-decl posinfo-gen x' Γ) (renamectxt-insert ρ x x') σ k)
 substh-kind Γ ρ σ (KndTpArrow t k) = KndTpArrow (substh-type Γ ρ σ t) (substh-kind Γ ρ σ k)
+substh-kind{QUALIF} Γ ρ σ (KndVar pi x xs) =
+   qualif-lookup-kind pi (substh-args Γ ρ σ xs) σ x
 substh-kind Γ ρ σ (KndVar pi x xs) = KndVar pi x (substh-args Γ ρ σ xs)
 substh-kind Γ ρ σ (Star pi) = Star pi
 
@@ -160,3 +174,14 @@
 rename-kind Γ x y tt k = subst-kind Γ (Var posinfo-gen y) x k
 rename-kind Γ x y ff k = subst-kind Γ (TpVar posinfo-gen y) x k
 
+substs-ret-t : Set → Set
+substs-ret-t T = {ed : exprd} → ctxt → trie ⟦ ed ⟧ → T → T
+
+substs-term : substs-ret-t term
+substs-term Γ = substh-term Γ empty-renamectxt
+
+substs-type : substs-ret-t type
+substs-type Γ = substh-type Γ empty-renamectxt
+
+substs-kind : substs-ret-t kind
+substs-kind Γ = substh-kind Γ empty-renamectxt
Index: src/syntax-util.agda
===================================================================
--- src/syntax-util.agda	(revision 27194)
+++ src/syntax-util.agda	(working copy)
@@ -12,8 +12,11 @@
 dummy-var : var
 dummy-var = "_dummy"
 
+qualif-info : Set
+qualif-info = var × args
+
 qualif : Set
-qualif = trie (var × args)
+qualif = trie qualif-info
 
 posinfo-to-ℕ : posinfo → ℕ
 posinfo-to-ℕ pi with string-to-ℕ pi
@@ -39,34 +42,69 @@
   TpLambda posinfo-gen posinfo-gen x tk (abs-expand-type ps t)
 abs-expand-type ParamsNil t = t
 
-inst-kind : params → args → kind → kind
-inst-kind ps as k = k
-
-inst-type : params → args → type → type
-inst-type ps as t = t
-
-qualif-term : qualif → term → term
-qualif-term σ t = t
-
-qualif-type : qualif → type → type
-qualif-type σ t = t
-
-qualif-kind : qualif → kind → kind
-qualif-kind σ k = k
+-- qualify variable by module name
+_#_ : string → string → string
+fn # v = fn ^ "." ^  v
+
+mk-inst : params → args → trie arg
+mk-inst (ParamsCons (Decl _ _ x _ _) ps) (ArgsCons a as) =
+  trie-insert (mk-inst ps as) x a
+mk-inst _ _ = empty-trie
+
+apps-term : term → args → term
+apps-term f (ArgsNil _) = f
+apps-term f (ArgsCons (TermArg t) as) = apps-term (App f NotErased t) as
+apps-term f (ArgsCons (TypeArg t) as) = apps-term (AppTp f t) as
+
+apps-type : type → args → type
+apps-type f (ArgsNil _) = f
+apps-type f (ArgsCons (TermArg t) as) = apps-type (TpAppt f t) as
+apps-type f (ArgsCons (TypeArg t) as) = apps-type (TpApp f t) as
+
+append-params : params → params → params
+append-params (ParamsCons p ps) qs = ParamsCons p (append-params ps qs)
+append-params ParamsNil qs = qs
+
+append-args : args → args → args
+append-args (ArgsCons p ps) qs = ArgsCons p (append-args ps qs)
+append-args (ArgsNil _) qs = qs
+
+qualif-lookup-term : posinfo → qualif → string → term
+qualif-lookup-term pi σ x with trie-lookup σ x
+... | just (x' , as) = apps-term (Var pi x') as
+... | _ = Var pi x
+
+qualif-lookup-type : posinfo → qualif → string → type
+qualif-lookup-type pi σ x with trie-lookup σ x
+... | just (x' , as) = apps-type (TpVar pi x') as
+... | _ = TpVar pi x
+
+qualif-lookup-kind : posinfo → args → qualif → string → kind
+qualif-lookup-kind pi xs σ x with trie-lookup σ x
+... | just (x' , as) = KndVar pi x' (append-args as xs)
+... | _ = KndVar pi x xs
+
+inst-lookup-term : posinfo → trie arg → string → term
+inst-lookup-term pi σ x with trie-lookup σ x
+... | just (TermArg t) = t
+... | _ = Var pi x
+
+inst-lookup-type : posinfo → trie arg → string → type
+inst-lookup-type pi σ x with trie-lookup σ x
+... | just (TypeArg t) = t
+... | _ = TpVar pi x
 
 params-to-args : params → args
 params-to-args ParamsNil = ArgsNil posinfo-gen
 params-to-args (ParamsCons (Decl _ p v (Tkt t) _) ps) = ArgsCons (TermArg (Var p v)) (params-to-args ps)
 params-to-args (ParamsCons (Decl _ p v (Tkk k) _) ps) = ArgsCons (TypeArg (TpVar p v)) (params-to-args ps)
 
--- TODO file-qualify once environment defs are also file-qualified
 qualif-insert-params : qualif → var → var → params → qualif
-qualif-insert-params σ fn v ps = trie-insert σ v (v , params-to-args ps)
+qualif-insert-params σ fn v ps = trie-insert σ v (fn # v , params-to-args ps)
 
--- TODO qualify codomain of import
-qualif-insert-import : qualif → 𝕃 string → args → qualif
-qualif-insert-import σ [] as = σ
-qualif-insert-import σ (v :: vs) as = qualif-insert-import (trie-insert σ v (v , as)) vs as
+qualif-insert-import : qualif → var → 𝕃 string → args → qualif
+qualif-insert-import σ fn [] as = σ
+qualif-insert-import σ fn (v :: vs) as = qualif-insert-import (trie-insert σ v (fn # v , as)) fn vs as
 
 tk-is-type : tk → 𝔹
 tk-is-type (Tkt _) = tt
@@ -205,18 +243,24 @@
   TYPE : exprd
   KIND : exprd
   LIFTINGTYPE : exprd
+  ARG : exprd
+  QUALIF : exprd
 
 ⟦_⟧ : exprd → Set
 ⟦ TERM ⟧ = term
 ⟦ TYPE ⟧ = type
 ⟦ KIND ⟧ = kind
 ⟦ LIFTINGTYPE ⟧ = liftingType
+⟦ ARG ⟧ = arg
+⟦ QUALIF ⟧ = qualif-info
 
 exprd-name : exprd → string
 exprd-name TERM = "term"
 exprd-name TYPE = "type"
 exprd-name KIND = "kind"
 exprd-name LIFTINGTYPE = "lifting type"
+exprd-name ARG = "argument"
+exprd-name QUALIF = "qualification"
 
 -- checking-sythesizing enum
 data checking-mode : Set where
Index: src/to-string.agda
===================================================================
--- src/to-string.agda	(revision 27194)
+++ src/to-string.agda	(working copy)
@@ -5,7 +5,6 @@
 open import syntax-util
 open import ctxt
 
-
 markup-h : (tags : 𝕃 string) → (vals : 𝕃 string) → string → string
 markup-h (th :: t) (vh :: vt) s = markup-h t vt (s ^ (" " ^ th ^ "='" ^ vh ^ "'"))
 -- Had to use "t" to refer to the tag tail since "tt" is the name for the Boolean true
@@ -78,7 +77,9 @@
 tk-to-string : ctxt → tk → string
 liftingType-to-string : ctxt → liftingType → string
 liftingType-to-stringh : {ed : exprd} → ctxt → ⟦ ed ⟧ → liftingType → string
+qualif-to-string : ctxt → qualif-info → string
 maybeAtype-to-string : ctxt → maybeAtype → string
+arg-to-string : ctxt → arg → string
 args-to-string : ctxt → args → string
 
 -- If the first or second argument (toplevel, locally-not-needed) is true, don't put parens; else put parens
@@ -92,6 +93,7 @@
 type-to-string Γ toplevel tp = type-to-stringh Γ toplevel star tp
 kind-to-string Γ toplevel k = kind-to-stringh Γ toplevel star k
 liftingType-to-string Γ l = liftingType-to-stringh Γ star l
+qualif-to-string Γ (x , as) = x ^ args-to-string Γ as
 
 term-to-stringh Γ toplevel p (App t x t') = 
   parens-unless toplevel ((is-beta p) || (is-app p)) (term-to-stringh Γ ff (App t x t') t ^ " " ^ (maybeErased-to-string x) ^ term-to-string Γ ff t')
@@ -160,8 +162,9 @@
 kind-to-stringh Γ toplevel p (KndVar _ x ys) = x ^ args-to-string Γ ys
 kind-to-stringh Γ toplevel p (Star _) = "★"
 
-args-to-string Γ (ArgsCons (TermArg t) ys) = " " ^ term-to-string Γ ff t ^ args-to-string Γ ys
-args-to-string Γ (ArgsCons (TypeArg t) ys) = " · " ^ type-to-string Γ ff t ^ args-to-string Γ ys
+arg-to-string Γ (TermArg t) = term-to-string Γ ff t
+arg-to-string Γ (TypeArg t) = type-to-string Γ ff t
+args-to-string Γ (ArgsCons y ys) = " " ^ arg-to-string Γ y ^ args-to-string Γ ys
 args-to-string _ (ArgsNil _) = ""
 
 liftingType-to-stringh Γ p (LiftArrow t t₁) = 
@@ -194,12 +197,13 @@
 maybeAtype-to-string _ NoAtype = ""
 maybeAtype-to-string Γ (Atype T) = type-to-string Γ ff T
 
-
 to-string : {ed : exprd} → ctxt → ⟦ ed ⟧ → string
 to-string{TERM} Γ = term-to-string Γ tt
 to-string{TYPE} Γ = type-to-string Γ tt
 to-string{KIND} Γ = kind-to-string Γ tt
 to-string{LIFTINGTYPE} = liftingType-to-string
+to-string{ARG} = arg-to-string
+to-string{QUALIF} = qualif-to-string
 
 to-string-if : ctxt → {ed : exprd} → maybe (⟦ ed ⟧) → string
 to-string-if mΓ (just e) = to-string mΓ e
Index: src/toplevel-state.agda
===================================================================
--- src/toplevel-state.agda	(revision 27194)
+++ src/toplevel-state.agda	(working copy)
@@ -141,6 +141,6 @@
 scope-imports s import-fn with toplevel-state.Γ s
 ... | mk-ctxt (fn , ps , q) syms i symb-occs with trie-lookup syms import-fn
 ... | nothing = s
-... | just vs = let q' = qualif-insert-import q vs (ArgsNil posinfo-gen) in
+... | just vs = let q' = qualif-insert-import q import-fn vs (ArgsNil posinfo-gen) in
   record s { Γ = mk-ctxt (fn , ps , q') syms i symb-occs }
 
