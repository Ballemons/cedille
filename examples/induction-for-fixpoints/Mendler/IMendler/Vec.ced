import Helper.
import Product.
import Sigma.
import Sum.
import ProductImplicit.
import SumImplicit.
import Unit.
import Functor.
import Fixpoint.

import IFunctor.
import IFixpoint.
import IInduction.
import Nat.

VecF ◂ ★ ➔ (NatM ➔ ★) ➔ (NatM ➔ ★) =
  λ A : ★ . λ Vec : NatM ➔ ★ . λ n : NatM .
  SumImplicit · (n ≃ zero)
      · (Sigma · NatM · (λ p : NatM . ProductImplicit · (n ≃ suc p) · (Product · A · (Vec p)))) .

VecFF ◂ ∀ A : ★ . IFunctor · NatM · (VecF · A) =
  Λ A . Λ X . Λ Y . λ i . λ c . λ v .
    v.1 · (VecF · A · Y i)
      (Λ e . inImpl1 · (i ≃ zero) · (Sigma · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (Y p)))) -e)
      (λ pr .
        inImpl2 · (i ≃ zero) · (Sigma · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (Y p))))
	(mkdsigma · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (Y p)))
	 (proj1 · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) pr)
         (pairImpl · (i ≃ suc (proj1 pr)) · (Product · A · (Y (proj1 · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) pr)))
	   -(((proj2 · NatM · (λ p : NatM . ProductImplicit · (i ≃ (suc p)) · (Product · A · (X p))) pr).1)
	       · (i ≃ suc (proj1 pr))
	         (Λ a . λ b . ρ a - β))
	    (pair · A · (Y (proj1 · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) pr))
	      (fst · A · (X (proj1 · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) pr))
	        (sndImpl ·
		  (i ≃ suc (proj1 pr)) ·
	          (Product · A · (X (proj1 · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) pr)))
		  (proj2 · NatM · (λ p : NatM . ProductImplicit · (i ≃ (suc p)) · (Product · A · (X p))) pr)))
	      (c (proj1 · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) pr)
	        (snd · A · (X (proj1 · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) pr))
	        ((sndImpl ·
	          (i ≃ suc (proj1 · NatM · (λ p : NatM . Product · (i ≃ suc p) · (Product · A · (X p))) pr)) ·
	          (Product · A · (X (proj1 · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) pr)))
	          ((proj2 · NatM · (λ p : NatM . ProductImplicit · (i ≃ (suc p)) · (Product · A · (X p))) pr))))))
		  )))) .

lemma0 ◂ ∀ A : ★ . ∀ B : ★ . Π pr : ProductImplicit · A · B . pairImpl (sndImpl pr) ≃ pr =
           Λ A . Λ B . λ pr . ind-ProductImplicit · A · B pr · (λ x : ProductImplicit · A · B . pairImpl (sndImpl x) ≃ x)
	                      (Λ a . λ b . β).
			      
lemma0-1 ◂ ∀ A : ★ . ∀ B : ★ . Π pr : Product · A · B . pair (fst pr) (snd pr) ≃ pr =
           Λ A . Λ B . λ pr . ind-Product · A · B pr · (λ x : Product · A · B . pair (fst x) (snd x) ≃ x)
	                      (λ a . λ b . β).
			      
lemma1 ◂ ∀ A : ★ . ∀ i : NatM . ∀ X : NatM ➔ ★ . Π s : (Sigma · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p)))) .
         (mkdsigma (proj1 s) (pairImpl (pair (fst (sndImpl (proj2 s))) (snd (sndImpl (proj2 s)))))) ≃ s =
	 Λ A : ★ . Λ i : NatM . Λ X : NatM ➔ ★ . λ s .
	   ind-sigma · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) s
	   · (λ s : Sigma · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (X p)))) .
	       (mkdsigma (proj1 s) (pairImpl (pair (fst (sndImpl (proj2 s))) (snd (sndImpl (proj2 s)))))) ≃ s)
	       (λ a . λ b . εl (εr (ρ (proj1inv · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) a b)
	                              -
				      (ρ (proj2inv · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) a b) -
				        (ρ (lemma0-1 · A · (X a) (sndImpl · (i ≃ suc a) · (Product · A · (X a)) b)) -
					 (ρ (lemma0 · (i ≃ suc a) · (Product · A · (X a)) b) - β)))))).
					  



VecFlaw1 ◂ ∀ A : ★ . IFunctorLaw1 · NatM · (VecF · A) (VecFF · A) =
  Λ A . Λ X . Λ Y . Λ f . λ i . λ u . Λ e . θ<u> (ind-SumImplicit · (i ≃ zero)
      · (Sigma · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p)))) u)
      (Λ a . β)
      (λ b . εl (εr (ρ (e (proj1 · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) b)
                           (snd · A · (X (proj1 · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) b)) (sndImpl · (i ≃ (suc (proj1 b))) · (Product · A · (X (proj1 · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) b))) (proj2 · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (X p))) b )))) -
			   (ρ (lemma1 · A -i · X b) - β)))) . 

VecM ◂ ★ ➔ NatM ➔ ★ = λ A : ★ . IFixIndM · NatM · (VecF · A) (VecFF · A) .

Nil ◂ ∀ A : ★ . VecM · A zero = Λ A . inIFixIndM · NatM · (VecF · A) (VecFF · A) -(VecFlaw1 · A) zero (inImpl1 · (zero ≃ zero) ·
         (Sigma · NatM · (λ p : NatM . ProductImplicit · (zero ≃ suc p) · (Product · A · (VecM · A p)))) -β) .

Cons ◂ ∀ A : ★ . Π n : NatM . A ➔ (VecM · A n) ➔ (VecM · A (suc n)) =
         Λ A . λ n . λ a . λ vs . inIFixIndM · NatM · (VecF · A) (VecFF · A) -(VecFlaw1 · A) (suc n)
	 (inImpl2 · ((suc n) ≃ zero)
	      · (Sigma · NatM · (λ p : NatM . ProductImplicit · ((suc n) ≃ (suc p)) · (Product · A · (VecM · A p))))
	     (mkdsigma · NatM · (λ p : NatM . ProductImplicit · ((suc n) ≃ (suc p)) · (Product · A · (VecM · A p)))
	        n
	       (pairImpl · (suc n ≃ suc n) · (Product · A · (VecM · A n))
	         -β
		 (pair · A · (VecM · A n) a vs)))
	      ).

% "let" would allow us to clean this up considerably, but it is doing
% strange things -- causing the type-checker to say two types are not
% convertible when they are convertible

% Running a M-% and replacing the let definition with the symbol being
% defined should work here, but does not.

VecInd ◂ ∀ A : ★ . ∀ Q : (Π n : NatM . VecM · A n ➔ ★) .
         Q zero (Nil · A) ➔
	 (Π m : NatM . ∀ vs : VecM · A m . ∀ a : A . Q m vs ➔ Q (suc m) (Cons · A m a vs)) ➔
	 Π n : NatM . Π vs : VecM · A n . Q n vs =
	 Λ A . Λ Q . λ n . λ c .
	   InductionFixIndM · NatM · (VecF · A) (VecFF · A) (VecFlaw1 · A) · Q
	     (Λ R . Λ cast . Λ castId . λ ih . λ i . λ vf .
	     θ<vf> (ind-SumImplicit · (i ≃ zero) · (Sigma · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p))))) vf)
	      (Λ u . ρ (VecFlaw1 · A · R · (VecM · A) -cast i (inImpl1 · (i ≃ zero) · (Sigma · NatM · (λ p : NatM . ProductImplicit · (i ≃ suc p) · (Product · A · (R p)))) -u) -castId) -
	             (ρ u - n))
	      (λ b . 
	             let pred = (proj1 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b) in
		     let pr = (sndImpl · (i ≃ (suc (proj1 b))) · (Product · A · (R (proj1 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b)))
			         (proj2 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b)) in
	             ρ (((proj2 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p))))  b).1) · (i ≃ suc (proj1 b)) (Λ a . λ b . ρ a - β)) - 
	             (c (proj1 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b)
	              -(cast (proj1 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b)
		             (snd · A · (R (proj1 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b))
			       (sndImpl · (i ≃ (suc (proj1 b))) · (Product · A · (R (proj1 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b)))
			         (proj2 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b))))
		       -(fst · A · (R (proj1 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b))
			     (sndImpl · (i ≃ (suc (proj1 b))) · (Product · A · (R (proj1 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b)))
			         (proj2 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b)))
	               (ih (proj1 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b)
	                   (snd · A · (R (proj1 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b))
			     (sndImpl · (i ≃ (suc (proj1 b))) · (Product · A · (R (proj1 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b)))
			         (proj2 · NatM · (λ p : NatM . (ProductImplicit · (i ≃ (suc p)) · (Product · A · (R p)))) b))))))).
