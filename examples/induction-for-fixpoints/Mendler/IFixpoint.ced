
% define indexed types + induction
% example of mutual datatypes, GADTs, nested types + maybe some handy infrastructure for them?
% tiny example of metatheories a la carte?

%indexed functor kind

import ../IFunctor.
iMalgebra ◂ Π I : ★ . 𝒌IFKind · I ➔ (I ➔ ★) ➔ ★ =
  λ I : ★ .
  λ F : 𝒌IFKind · I .
  λ A : I ➔ ★ .
  ∀ R : I ➔ ★ .
  (Π i : I . R i ➔ A i) ➔
  Π i : I .
  F · R i ➔ A i   .

iFix ◂ Π I : ★ . 𝒌IFKind · I ➔ I ➔ ★ =
  λ I : ★ .
  λ F : 𝒌IFKind · I .
  λ i : I .
  ∀ A : (I ➔ ★) . iMalgebra · I · F · A ➔ A i .

imfold ◂ ∀ I : ★ . ∀ F : 𝒌IFKind · I . ∀ A : I ➔ ★ . iMalgebra · I · F · A ➔ Π i : I . iFix · I · F i ➔ A i
  = Λ I . Λ F . Λ A . λ alg . λ i . λ fix . fix · A alg . 

inIM ◂ ∀ I : ★ . ∀ F : 𝒌IFKind · I . Π i : I . F · (iFix · I · F) i ➔ iFix · I · F i =
  Λ I . Λ F . λ i . λ ffix .
    Λ A . λ malg . malg · (iFix · I · F) (imfold · I · F · A malg) i ffix    .



% inductivity predicate     
isInductiveFixM ◂ Π I : ★ . Π G : 𝒌IFKind · I . IFunctor · I · G ➔ Π i : I . (iFix · I · G i) ➔ ★ 
   = λ I : ★ .
     λ G : 𝒌IFKind · I.
     λ ifmap : IFunctor · I · G.
     λ i : I.
     λ ifix : iFix · I · G i.
     ∀ Q : iFix · I · G i ➔ ★  .
     (∀ R : I ➔ ★ . ∀ cast : Π i : I . R i ➔ (iFix · I · G i) . (Π i : I . Π r : R i . cast i r ≃ r) ➾
           (Π i : I . Π r : R i . Q (cast i r)) ➔
           (Π i : I . Π gr : G · R i .  Q (inIM · I · G i (ifmap · R · (iFix · I · G) i cast gr)))) ➔ 
	   
     Q ifix .
     
DepFixM ◂ Π I : ★ . Π G : 𝒌IFKind · I . IFunctor · I · G ➔ I ➔ ★
  = λ I : ★ . λ G : 𝒌IFKind · I . λ ifmap : IFunctor · I · G . λ i : I .
    ι x : iFix · I · G i . isInductiveFixM · I · G ifmap i x.


inDepFixM ◂ ∀ I : ★ . ∀ G : 𝒌IFKind · I . Π ifmap : IFunctor · I · G . ∀ IFLaw1 : IFunctorLaw1 · I · G ifmap .
            Π i : I . G · (DepFixM · I · G ifmap) i ➔ DepFixM · I · G ifmap i
  = Λ I . Λ G . λ ifmap . Λ iflaw1 . λ i . λ gd .
     [ inIM · I · G i (ifmap · (DepFixM · I · G ifmap) · (iFix · I · G) i (λ _ . λ z . z.1) gd)  
     ,
     (Λ Q . λ q . q · (DepFixM · I · G ifmap) -(λ i . λ d . d.1) -(λ i . λ r . β) (λ i . λ r . r.2 · Q q) i gd ) 
     {  ε (ρ  (iflaw1 · (DepFixM · I · G ifmap) · (iFix · I · G) -(λ _ . λ d . d.1) i gd -(λ i . λ r . β)  ) - β)  }
     ] .



