
% define indexed types + induction
% example of mutual datatypes, GADTs, nested types + maybe some handy infrastructure for them?
% tiny example of metatheories a la carte?

% indexed functor kind

import IFunctor.

iMalgebra ◂ Π I : ★ . (𝒌IFKind · I) ➔ (I ➔ ★) ➔ ★ =
  λ I : ★ .
  λ F : 𝒌IFKind · I .
  λ A : I ➔ ★ .
  ∀ R : I ➔ ★ .
  (Π i : I . R i ➔ A i) ➔
  Π i : I .
  F · R i ➔ A i .

iFix ◂ Π I : ★ . 𝒌IFKind · I ➔ I ➔ ★ =
  λ I : ★ .
  λ F : 𝒌IFKind · I .
  λ i : I .
  ∀ A : (I ➔ ★) . iMalgebra · I · F · A ➔ A i .

imfold ◂ ∀ I : ★ . ∀ F : 𝒌IFKind · I . ∀ A : I ➔ ★ . iMalgebra · I · F · A ➔ Π i : I . iFix · I · F i ➔ A i
  = Λ I . Λ F . Λ A . λ alg . λ i . λ fix . fix · A alg . 

inIM ◂ ∀ I : ★ . ∀ F : 𝒌IFKind · I . Π i : I . F · (iFix · I · F) i ➔ iFix · I · F i =
  Λ I . Λ F . λ i . λ ffix .
    Λ A . λ malg . malg · (iFix · I · F) (imfold · I · F · A malg) i ffix    .

outIM ◂ ∀ I : ★ . ∀ F : 𝒌IFKind · I . Π i : I . IFunctor · I · F ➔ iFix · I · F i ➔ F · (iFix · I · F) i =
  Λ I . Λ F . λ i . λ ifmap . λ fix . imfold · I · F · (F · (iFix · I · F))
    (Λ R . λ ih . λ i . λ fr . ifmap · R · (iFix · I · F) i (λ i . λ r .inIM · I · F i (ih i r)) fr) i fix .

% inductivity predicate     
isInductiveIFixM ◂ Π I : ★ . Π G : 𝒌IFKind · I . IFunctor · I · G ➔ Π i : I . (iFix · I · G i) ➔ ★ 
   = λ I : ★ .
     λ G : 𝒌IFKind · I.
     λ ifmap : IFunctor · I · G.
     λ i : I.
     λ ifix : iFix · I · G i.
     ∀ Q : iFix · I · G i ➔ ★  .
     (∀ R : I ➔ ★ . ∀ cast : Π i : I . R i ➔ (iFix · I · G i) . (Π i : I . Π r : R i . cast i r ≃ r) ➾
           (Π i : I . Π r : R i . Q (cast i r)) ➔
           (Π i : I . Π gr : G · R i .  Q (inIM · I · G i (ifmap · R · (iFix · I · G) i (λ i . (cast i)) gr)))) ➔ 
	   
     Q ifix .
     
DepFixM ◂ Π I : ★ . Π G : 𝒌IFKind · I . IFunctor · I · G ➔ I ➔ ★
  = λ I : ★ . λ G : 𝒌IFKind · I . λ ifmap : IFunctor · I · G . λ i : I .
    ι x : iFix · I · G i . isInductiveIFixM · I · G ifmap i x.


inDepFixM ◂ ∀ I : ★ . ∀ G : 𝒌IFKind · I . Π ifmap : IFunctor · I · G . ∀ IFLaw1 : IFunctorLaw1 · I · G ifmap .
            Π i : I . G · (DepFixM · I · G ifmap) i ➔ DepFixM · I · G ifmap i
  = Λ I . Λ G . λ ifmap . Λ iflaw1 . λ i . λ gd .
     [ inIM · I · G i (ifmap · (DepFixM · I · G ifmap) · (iFix · I · G) i (λ i . λ z . z.1) gd)  
     ,
     (Λ Q . λ q . q · (DepFixM · I · G ifmap) -(λ i . λ d . d.1) -(λ i . λ r . β) (λ i . λ r . r.2 · Q q) i gd ) 
     {  ε (ρ  (iflaw1 · (DepFixM · I · G ifmap) · (iFix · I · G) -(λ i . λ d . d.1) i gd -(λ i . λ z . β)) - β) }
     ] .

outIAlgM ◂ ∀ I : ★ . ∀ G : 𝒌IFKind · I . Π ifmap : IFunctor · I · G . ∀ IFLaw1 : IFunctorLaw1 · I · G ifmap .
     iMalgebra · I · G · (G · (DepFixM · I · G ifmap)) =
  Λ I . Λ G . λ ifmap . Λ iflaw1 . Λ R . λ ih . λ i . λ fr .
    ifmap · R · (DepFixM · I · G ifmap) i (λ i . λ r . inDepFixM · I · G ifmap -iflaw1 i (ih i r)) fr .
     
outDepFixM ◂ ∀ I : ★ . ∀ G : 𝒌IFKind · I . Π ifmap : IFunctor · I · G . ∀ IFLaw1 : IFunctorLaw1 · I · G ifmap .
          Π i : I . DepFixM · I · G ifmap i ➔ G · (DepFixM · I · G ifmap) i 
  = Λ I . Λ G . λ ifmap . Λ iflaw1 . λ i . λ ei .
      imfold · I · G · (G · (DepFixM · I · G ifmap))
        (outIAlgM · I · G ifmap -iflaw1)
	i
	ei.1.

% define simple outIm and dependent version of it outDepFixM
% try to phrase induction principle based on the predicate isInductiveIFixM
% examples


