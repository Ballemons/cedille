
import ../Functor.
import ../Sigma.
import ../Product.

import Church.
import Helper.

% Mendler-style algebra
AlgebraM ◂ (★ ➔ ★) ➔ ★ ➔ ★ = λ F : ★ ➔ ★ . λ A : ★ . ∀ R : ★ . (R ➔ A) ➔ F · R ➔ A .


WFAlgM ◂ Π F : ★ ➔ ★ . Functor · F ➔ Π A : ★ . AlgebraM · F · A ➔ ★ =
   λ F : ★ ➔ ★ . λ fmap : Functor · F . λ A : ★ . λ alg : AlgebraM · F · A .
   ∀ R : ★ . ∀ cast : R ➔  A . ∀ fr : F · R . alg cast fr ≃  alg (λ x . x) (fmap cast fr) .


% Fixpoint of F-malgebra
FixM ◂ (★ ➔ ★) ➔ ★ = λ F : ★ ➔ ★ . ∀ A : ★ . (∀ R : ★ . (R ➔ A) ➔ F · R ➔ A) ➔ A .


% FixM M is (weakly) initial
foldM ◂ ∀ F : ★ ➔ ★ . ∀ A : ★ . AlgebraM · F · A ➔ FixM · F ➔ A
  = Λ F . Λ A . λ alg . λ fix . fix · A alg .


inM ◂ ∀ F : ★ ➔ ★ . F · (FixM · F) ➔ FixM · F
   = Λ F .  λ fexp . Λ A . λ alg . alg · (FixM · F) (foldM · F · A alg) fexp.




outM ◂ ∀ F : ★ ➔ ★ . Functor · F ➔ FixM · F ➔ F · (FixM · F)
 = Λ F . λ fmap . λ fix . foldM · F · (F · (FixM · F))
   (Λ R . λ ih . λ fr . fmap · R · (FixM · F) (λ r . inM · F (ih r))  fr)
   fix  .



% inductivity predicate     
isInductiveFixM ◂ Π G : (★ ➔ ★) . Functor · G ➔ FixM · G ➔ ★
   = λ G : ★ ➔ ★ . λ fmap : Functor · G . λ x : FixM · G . ∀ Q : (FixM · G) ➔ ★ .
        (∀ R : ★ . ∀ cast : R ➔ (FixM · G) . (∀ r : R . cast r ≃ r) ➾
           (Π r : R . Q (cast r)) ➔
           (Π gr : G · R .  Q (inM · G (fmap · R · (FixM · G) cast gr)))) ➔ Q x  .




DepFixM ◂ Π G : (★ ➔ ★) . Functor · G ➔ ★
  = λ G : ★ ➔ ★ . λ fmap : Functor · G .
    ι x : FixM · G . isInductiveFixM · G fmap x .


foldMDep ◂ ∀ F : ★ ➔ ★ . Π fmap : Functor · F . ∀ A : ★ . AlgebraM · F · A ➔ DepFixM · F fmap ➔ A
  = Λ F . λ fmap . Λ A . λ alg . λ fix . foldM · F · A  alg fix.1 .



inDepFixM ◂ ∀ G : (★ ➔ ★) . Π fmap : Functor · G . FunctorLaw1 · G fmap 
             ➔ G · (DepFixM · G fmap) ➔ DepFixM · G fmap
  = Λ G . λ fmap . λ Flaw1 . λ ei .
    [ inM · G (fmap · (DepFixM · G fmap) · (FixM · G) (λ e . e.1) ei) 
    , (Λ Q . λ q . q · (DepFixM · G fmap) -(λ z . z.1) -(Λ r . β) (λ r . r.2 · Q q ) ei) 
    { ε (ρ (Flaw1 · (DepFixM · G fmap) · (DepFixM · G fmap) -(λ x . x) ei -(λ _ . β)  ) - β) }
    ].


outDepFixM ◂ ∀ G : (★ ➔ ★) . Π fmap : Functor · G . FunctorLaw1 · G fmap
             ➔ DepFixM · G fmap ➔ G · (DepFixM · G fmap)
  = Λ G . λ fmap . λ Flaw1 . λ ei .
     foldM · G · (G · (DepFixM · G fmap))
      (Λ R . λ ih . λ fr . fmap · R · (DepFixM · G fmap) (λ r . inDepFixM · G fmap Flaw1 (ih r))  fr)
      ei.1  .

InductionDepFixM ◂  ∀ G : ★ ➔ ★ . Π fmap : Functor · G . Π Flaw1 : FunctorLaw1 · G fmap .
    Π e : DepFixM · G fmap . ∀ Q : (DepFixM · G fmap) ➔ ★ . 
   (∀ R : ★ . ∀ cast : R ➔ (DepFixM · G fmap) . (∀ r : R . cast r ≃ r) ➾
    (Π r : R . Q (cast r)) ➔
    (Π gr : G · R .  Q (inDepFixM · G fmap Flaw1 (fmap · R · (DepFixM · G fmap) cast gr ) )))
     ➔ Q e = ● .
     

% seems to be not provable without functional extensionality
UniversalProperty ◂ Π G : (★ ➔ ★) . Π fmap : Functor · G .
    FunctorLaw1 · G fmap ➔
    (DepFixM · G fmap) ➔ ★ =
    λ G : ★ ➔ ★ .
    λ fmap : Functor · G .
    λ flaw1 : FunctorLaw1 · G fmap .
    λ fix : (DepFixM · G fmap) .
    Π A : ★ .
    Π h : (DepFixM · G fmap) ➔ A.
    Π f : AlgebraM · G · A .
    WFAlgM · G fmap · A f ➔ 
     (Π e : G · (DepFixM · G fmap) . h (inDepFixM · G fmap flaw1 e) ≃  f · (DepFixM · G fmap) h e)
          ➔ h fix ≃ foldM · G · A f fix .

% !!!
uni ◂ ∀ G : ★ ➔ ★ .
      Π fmap : Functor · G .
      Π flaw1 : FunctorLaw1 · G fmap .
      Π flaw2 : FunctorLaw2 · G fmap .
      Π fmapEq : FmapEq · G fmap .
             Π fix : DepFixM · G fmap . UniversalProperty · G fmap flaw1 fix
  =
    Λ G . λ fmap . λ flaw1 . λ flaw2 . λ fmapEq . λ fix . θ<fix> (InductionDepFixM · G fmap flaw1 fix)
       (Λ R . Λ cast . Λ castEq . λ q . λ gr . λ A . λ h . λ f . λ wf . λ z .
          ε ρ (flaw1 · (DepFixM · G fmap) · (DepFixM · G fmap)  -(λ x . x) (fmap · R · (DepFixM · G fmap) cast gr) -(λ z . β))  -
	      ρ (z (fmap · R · (DepFixM · G fmap) cast gr)) -
	       ρ (wf · (DepFixM · G fmap) -h -(fmap · R · (DepFixM · G fmap) cast gr))  -
	        ρ (wf · (DepFixM · G fmap) -(foldMDep · G fmap · A f) -(fmap · R · (DepFixM · G fmap) cast gr))  -
		 ρ (flaw2 · R · (DepFixM · G fmap) · A -h -cast gr ) -
    		  ρ (flaw2 · R · (DepFixM · G fmap) · A -(foldMDep · G fmap · A f) -cast gr ) -
		   ρ (fmapEq · R -β{(λ x' . (h (cast x')))}  -β{(λ x' . (foldMDep fmap f (cast x')))}
		           (λ r . q r · A h f wf z)
			      gr) - β) .



% reflection
idAlgM ◂ ∀ G : ★ ➔ ★ . Π fmap : Functor · G . FunctorLaw1 · G fmap ➔ AlgebraM · G · (DepFixM · G fmap)
  = Λ G . λ fmap . λ flaw1 . Λ R . λ ra . λ fr .  inDepFixM · G fmap flaw1  (fmap · R · (DepFixM · G fmap)  ra fr)  .


idAlgMWF ◂ ∀ G : ★ ➔ ★ . Π fmap : Functor · G . Π flaw1 : FunctorLaw1 · G fmap . WFAlgM · G fmap · (DepFixM · G fmap) (idAlgM · G fmap flaw1)
  = Λ G . λ fmap . λ flaw1 . Λ R . Λ cast . Λ fr . ε (ρ  (flaw1 · (DepFixM · G fmap) · (DepFixM · G fmap)  -(λ x . x) (fmap · R · (DepFixM · G fmap) cast fr) -(λ z . β))
     - ρ (flaw1 · (DepFixM · G fmap) · (DepFixM · G fmap)  -(λ x . x) (fmap · R · (DepFixM · G fmap) cast fr) -(λ z . β)) - β)     .

reflection ◂ ∀ G : ★ ➔ ★ .
             Π fmap : Functor · G .
             Π flaw1 : FunctorLaw1 · G fmap .
             Π flaw2 : FunctorLaw2 · G fmap .
             Π fmapEq : FmapEq · G fmap .
	     
             Π fix : DepFixM · G fmap .
	     foldM (idAlgM · G fmap flaw1) fix ≃ fix =
 Λ G . λ fmap . λ flaw1 . λ flaw2 . λ fmapEq . λ fix . ρ ς
    ((uni · G fmap flaw1 flaw2 fmapEq fix) ·
       (DepFixM · G fmap)
       (λ x . x)
       (idAlgM · G fmap flaw1)
       (idAlgMWF · G fmap flaw1)
       (λ e . ε (ρ (flaw1 · (DepFixM · G fmap) · (DepFixM · G fmap) -(λ x . x) e -(λ z . β)) -
                   ρ (flaw1 · (DepFixM · G fmap) · (DepFixM · G fmap) -(λ x . x) e -(λ z . β)) - β))) -
		    β .


% cancellation
cancellation ◂ ∀ G : ★ ➔ ★ . 
                Π fmap : Functor · G . 
                Π flaw1 : FunctorLaw1 · G fmap .

                Π gfix : G · (DepFixM · G fmap) .
               ∀ A : ★ . 
	        Π alg : AlgebraM · G · A .
                WFAlgM · G fmap · A alg ➔
	        foldM alg (inDepFixM fmap flaw1 gfix) ≃ 
                       alg (λ x . x) (fmap (foldM alg) gfix) = 
  Λ G . λ fmap . λ flaw1 . λ gfix . Λ A . λ alg . λ wfalg . 
   ρ+ (flaw1 · (DepFixM · G fmap) · (DepFixM · G fmap) -(λ x . x) gfix -(λ z . β)) - 
        (wfalg · (DepFixM · G fmap) -(foldMDep  · G  fmap · A alg) -gfix) .


% fusion
fusion ◂ ∀ G : ★ ➔ ★ . Π fmap : Functor · G . Π flaw1 : FunctorLaw1 · G fmap .
             Π fix : (DepFixM · G fmap) .
	     ∀ C : ★ . ∀ D : ★ . 
             Π f : C ➔ D . 
	     Π alg1 : AlgebraM · G · C .
             WFAlgM · G fmap · C alg1 ➔ 
	     Π alg2 : AlgebraM · G · D .
             WFAlgM · G fmap · D alg2 ➔ 
             (Π gc : G · C .  f (alg1 (λ x . x) gc) ≃ alg2 (λ x . x) (fmap f gc)) ➔ 
             f (foldM alg1 fix) ≃ foldM alg2 fix = 
  Λ G . λ fmap . λ flaw1 . λ fix . θ<fix> (InductionDepFixM · G fmap flaw1 fix)
   (Λ R . Λ cast . Λ castEq . λ q . λ gr . Λ C . Λ D . λ f . λ alg1 . λ wf1 . λ alg2 . λ wf2 . ●  )  .



% f ((alg1 (foldM alg1) (fmap (λ e . e) (fmap cast gr))))   = (alg2 (foldM alg2) (fmap (λ e . e) (fmap cast gr)))
% f ((alg1 (λ x . x) (fmap (foldM alg1) (fmap (λ e . e) (fmap cast gr))))) =   (alg2 (λ x . x) (fmap (foldM alg2) (fmap (λ e . e) (fmap cast gr))))
% f ((alg1 (λ x . x) (fmap (foldM alg1) ((fmap cast gr))))) =   (alg2 (λ x . x) (fmap (foldM alg2) ((fmap cast gr))))
% f ((alg1 (λ x . x) (fmap (foldM alg1 (cast r)) gr))) =   (alg2 (λ x . x) (fmap f ((foldM alg1 (cast r))) gr))



% introduction
  % type theory
  % extensions
  % language
% defining cNat : (X -> X) -> X -> X
% defining Nat as intersection
% proving induction principle for this case
% generalizing to Church and showing the problem
% Mendler in details
% Examples
% Mendler to Church, Church to Mendler?
% Conclusions
