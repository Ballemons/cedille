import bool.
import mybase.
import paramor.
import paramtrue.

% define natural numbers as a fixpoint of F X
cNat ◂ ★ = ∀ X : ★ . ((Or · True · X) ➔ X) ➔  X .

% cFold gives a morphism to any other F-algebra 
cFold ◂ ∀ X : ★ . ((Or · True · X) ➔ X) ➔ cNat ➔ X = Λ X . λ k . λ t . t · X k .

cIn ◂ (Or · True · cNat) ➔ cNat =
   λ s . Λ X . λ k . k (fmap · cNat · X (cFold · X k) s)  .


% Proof that (cNat, cIn) is an (weakly initial) F-algebra from which
% there is a map (cFold X k) to every other F-algebra
lem2 ◂ ∀ X : ★ . ∀ k : ((Or · True · X) ➔ X) .
    comp cIn (cFold · X k) ≃ comp (fmap · cNat · X (cFold · X k)) k
 = Λ X . Λ k . β .


cOut ◂ cNat ➔ Or · True · cNat = cFold · (Or · True · cNat) (fmap · (Or · True · cNat) · cNat cIn) .
% cOut0' ◂ cNat ➔ Or · True · cNat = λ n . n · (Or · True · cNat) () .

% show that (cIn, cOut) are isomorphism
%cOut-cIn ◂ Π n : cNat . (comp · (Or · True · cNat) · cNat cOut cIn) n ≃ n = λ n . β .

cIn-cOut-com ◂
  (comp cIn cOut) ≃ comp (fmap cOut) (fmap cIn)
   = lem2 · (Or · True · cNat) -(fmap · (Or · True · cNat) · cNat cIn) .



% TODO: fold properties

% generic definition of zero and successor
cZ ◂ cNat = cIn (Ori1 · True · cNat triv) .
cS ◂ cNat ➔ cNat = λ n . cIn (Ori2 · True · cNat n) .

% statement of Reynold's parametricity for cNat
ParamNatF ◂ cNat ➔ ★ = λ f : cNat .
 ∀ X : ★ . ∀ Y : ★ . ∀ R : X ➔ Y ➔ ★.
  ∀ p : Or · True · X ➔ X .
   ∀ q : Or · True · Y ➔ Y .
    (∀ r : Or · True · X .
      ∀ s : Or · True · Y .
        (∀ Z : ★ . ∀ W : ★ . ∀ S : Z ➔ W ➔ ★ .
         ∀ p1 : True ➔ Z.
          ∀ p2 : True ➔ W.
           (Π x : True. S (p1 x) (p2 x))
            ➔ (∀ p3 : X ➔ Z.
                 ∀ p4 : Y ➔ W.
                  (∀ y : X . ∀ z : Y . R y z ➔ S (p3 y) (p4 z))
                  ➔ (S (r.1 · Z p1 p3) (s.1 · W p2 p4))))
       ➔ (R (p r) (q s)))
    ➔ (R (f · X p) (f · Y q)).

       
% Natural numbers with induction
Nat ◂ ★ = ι x : cNat . ParamNatF x .

fold ◂ ∀ X : ★ . ((Or · True · X) ➔ X) ➔ Nat ➔ X = Λ X . λ k . λ t . t.1 · X k .

% updating the constructors
Z ◂ Nat = [ cZ , Λ X  .  Λ Y . Λ R . Λ p . Λ q . λ r . r -(Ori1 · True · X triv) -(Ori1 · True · Y triv)
           (Λ t3 . Λ t4 . Λ S . Λ p1 . Λ p2 . λ i1 . Λ p3 . Λ p4 . λ i2 . (i1 triv))  ] .
	   
S ◂ Nat ➔ Nat =  λ n . [ cS n.1 , Λ X  .  Λ Y . Λ R . Λ p . Λ q . λ r .
   r -(Ori2 · True · X (n.1 · X p)) -(Ori2 · True · Y (n.1 · Y q))
  (Λ t3 . Λ t4 . Λ S . Λ p1 . Λ p2 . λ i1 . Λ p3 . Λ p4 . λ i2 .
        (i2 -(n.1 · X p) -(n.1 · Y q) (n.2 · X · Y · R -p -q r)) )  ] .


% fold · (Or · True · Nat) (fmap · (Or · True · Nat) · Nat in) .

% define out and show isomorphism
in  ◂ (Or · True · Nat) ➔ Nat =   λ s . s.1 · Nat (λ _ . Z) S . % definition using fold and fmap is complicated due to iota!

param-reb ◂ Π n : Nat . n · Nat in ≃ n = ● .

NatInduction ◂ Π x : Nat . ∀ Q : Nat ➔ ★ . (∀ x : Nat . Q x ➔ Q (S x)) ➔ Q Z ➔ Q x = λ x . Λ Q . λ sc . λ z .
   ρ ς  (param-reb x) -  (x.2 · Nat · Nat · (λ n1 : Nat . λ n2 : Nat . Q n1)
       -in -in
         (Λ r . Λ s . λ k . k · Nat · Nat · (λ n1 : Nat . λ n2 : Nat . Q n1) -(λ _ . Z) -(λ _ . Z) (λ x . z) -S -S
	     (Λ y . Λ z . λ qy . sc -y qy)))  .


out ◂ Nat ➔ (Or · True · Nat)  = λ n . n.1 · (Or · True · Nat) (λ o . o.1 · (Or · True · Nat) (Ori1 · True · Nat) (λ o . o.1 · (Or · True · Nat) (λ _ . Ori2 · True · Nat Z) (λ n . Ori2 · True · Nat (S n))))    .


Out-In' ◂ Π o : Or · True · Nat .  in (o (λ _ . Ori2 Z) (λ n . Ori2  (S n))) ≃ S (in o) = λ o .
  θ<o> (OrInduction · True · Nat o) (Λ _ . β) (Λ y . β).
Out-In'' ◂ Π n : Nat . (out (S n)) ≃ (out n) (λ _ . Ori2 Z) (λ n . Ori2  (S n)) = λ n . θ<n> (NatInduction n) (Λ x . λ e . ρ e - β) β.
Out-In''' ◂ Π n : Nat . (in (out (S n))) ≃ S (in (out n)) = λ n . ρ (Out-In'' n) - ρ (Out-In' (out n)) - β .

out-in ◂ Π n : Nat . (in (out n)) ≃ n = λ n .  θ<n> (NatInduction n) (Λ x . λ e . ρ (Out-In''' x) - ρ e - β) β.


% in-out' ◂ Π y : Nat . (in (Ori2 y)) ≃ S y = λ o . β .
in-out'' ◂ Π y : Nat . (out (S y)) ≃ (Ori2 y) = λ n .  θ<n> (NatInduction n) (Λ x . λ e . ρ (Out-In'' (S x)) - ρ e - β) β .
in-out''' ◂ Π y : True . (in (Ori1 y)) ≃ Z = λ o . β .
in-out'''' ◂ (out Z) ≃ (Ori1 triv) = β   .

in-out ◂ Π o : Or · True · Nat . (out (in o)) ≃  o = λ n .  θ<n> (OrInduction · True · Nat n) (Λ x . ρ (in-out''' x) - (ρ (in-out'''') - (ρ (unique-inh' x) - β )))
  (Λ y .  ρ (in-out'' y) - β ) .
